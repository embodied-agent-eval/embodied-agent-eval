[
    {
        "identifier": "assembling_gift_baskets_0_Beechwood_0_int_0_2021-10-26_12-46-37",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem assembling_gift_baskets)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent basket_n_01_1 basket_n_01_2 - basket_n_01 bow_n_08_2 - bow_n_08 candle_n_01_1 - candle_n_01 cheese_n_01_1 - cheese_n_01 cookie_n_01_1 - cookie_n_01 floor_n_01_1 - floor_n_01 table_n_02_1 table_n_02_2 - table_n_02)\n    (:init (onfloor basket_n_01_1 floor_n_01_1) (onfloor basket_n_01_2 floor_n_01_1) (ontop bow_n_08_2 table_n_02_2) (ontop candle_n_01_1 table_n_02_1) (ontop cheese_n_01_1 table_n_02_2) (ontop cookie_n_01_1 table_n_02_1))\n    (:goal (and (inside bow_n_08_2 basket_n_01_2) (inside candle_n_01_1 basket_n_01_2) (inside cheese_n_01_1 basket_n_01_1) (inside cookie_n_01_1 basket_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "bottling_fruit_0_Wainscott_0_int_0_2021-05-24_19-46-46",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem bottling_fruit)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent carving_knife_n_01_1 - carving_knife_n_01 countertop_n_01_1 - countertop_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 jar_n_01_1 jar_n_01_2 - jar_n_01 peach_n_03_1 - peach_n_03 strawberry_n_01_1 - strawberry_n_01)\n    (:init (inside peach_n_03_1 electric_refrigerator_n_01_1) (inside strawberry_n_01_1 electric_refrigerator_n_01_1) (not (sliced peach_n_03_1)) (not (sliced strawberry_n_01_1)) (ontop carving_knife_n_01_1 countertop_n_01_1) (ontop jar_n_01_1 countertop_n_01_1) (ontop jar_n_01_2 countertop_n_01_1))\n    (:goal (and (sliced strawberry_n_01_1) (sliced peach_n_03_1) (inside peach_n_03_1 jar_n_01_1) (not (inside strawberry_n_01_1 jar_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action slice_carvingknife)\n:parameters (?obj - object ?knife - carving_knife_n_01 ?board - countertop_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "boxing_books_up_for_storage_0_Benevolence_1_int_0_2021-09-10_15-35-47",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem boxing_books_up_for_storage)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent book_n_02_2 book_n_02_5 book_n_02_6 book_n_02_7 - book_n_02 carton_n_02_1 - carton_n_02 floor_n_01_1 - floor_n_01 shelf_n_01_1 - shelf_n_01)\n    (:init (onfloor book_n_02_2 floor_n_01_1) (onfloor book_n_02_5 floor_n_01_1) (onfloor carton_n_02_1 floor_n_01_1) (ontop book_n_02_6 shelf_n_01_1) (ontop book_n_02_7 shelf_n_01_1))\n    (:goal (and (inside book_n_02_5 carton_n_02_1) (inside book_n_02_2 carton_n_02_1) (inside book_n_02_7 carton_n_02_1) (inside book_n_02_6 carton_n_02_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "bringing_in_wood_0_Benevolence_1_int_0_2021-09-15_18-42-25",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem bringing_in_wood)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 floor_n_01_2 - floor_n_01 plywood_n_01_1 plywood_n_01_2 plywood_n_01_3 - plywood_n_01)\n    (:init (onfloor plywood_n_01_1 floor_n_01_1) (onfloor plywood_n_01_2 floor_n_01_1) (onfloor plywood_n_01_3 floor_n_01_1))\n    (:goal (and (onfloor plywood_n_01_1 floor_n_01_2) (onfloor plywood_n_01_3 floor_n_01_2) (onfloor plywood_n_01_2 floor_n_01_2)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_onfloor)\n:parameters (?obj_in_hand - object ?floor - floor_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "brushing_lint_off_clothing_0_Pomaria_2_int_0_2021-06-04_17-41-56",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem brushing_lint_off_clothing)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bed_n_01_1 - bed_n_01 floor_n_01_1 - floor_n_01 scrub_brush_n_01_1 - scrub_brush_n_01 sweater_n_01_1 sweater_n_01_2 sweater_n_01_3 sweater_n_01_4 - sweater_n_01)\n    (:init (dusty sweater_n_01_1) (dusty sweater_n_01_2) (dusty sweater_n_01_3) (not (dusty scrub_brush_n_01_1)) (onfloor scrub_brush_n_01_1 floor_n_01_1) (onfloor sweater_n_01_1 floor_n_01_1) (onfloor sweater_n_01_2 floor_n_01_1) (ontop sweater_n_01_3 bed_n_01_1) (ontop sweater_n_01_4 bed_n_01_1))\n    (:goal (and (ontop sweater_n_01_1 bed_n_01_1) (not (dusty sweater_n_01_1)) (ontop sweater_n_01_2 bed_n_01_1) (ontop sweater_n_01_3 bed_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_brush)\n:parameters (?scrub_brush - scrub_brush_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "chopping_vegetables_0_Rs_int_0_2021-05-25_22-01-16",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem chopping_vegetables)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 chestnut_n_03_1 chestnut_n_03_2 - chestnut_n_03 countertop_n_01_1 - countertop_n_01 dish_n_01_2 - dish_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 knife_n_01_1 - knife_n_01 mushroom_n_05_1 mushroom_n_05_2 - mushroom_n_05 tomato_n_01_1 tomato_n_01_2 - tomato_n_01 vidalia_onion_n_01_2 - vidalia_onion_n_01)\n    (:init (inside dish_n_01_2 cabinet_n_01_1) (inside vidalia_onion_n_01_2 electric_refrigerator_n_01_1) (ontop chestnut_n_03_1 countertop_n_01_1) (ontop chestnut_n_03_2 countertop_n_01_1) (ontop knife_n_01_1 countertop_n_01_1) (ontop mushroom_n_05_1 countertop_n_01_1) (ontop mushroom_n_05_2 countertop_n_01_1) (ontop tomato_n_01_1 countertop_n_01_1) (ontop tomato_n_01_2 countertop_n_01_1))\n    (:goal (and (sliced vidalia_onion_n_01_2) (inside chestnut_n_03_1 dish_n_01_2) (sliced tomato_n_01_1) (sliced mushroom_n_05_1)))\n)\nAction to be finished:\n(:action slice)\n:parameters (?obj - object ?knife - knife_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_a_car_0_Ihlen_0_int_0_2021-09-11_16-37-11",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_a_car)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bucket_n_01_1 - bucket_n_01 car_n_01_1 - car_n_01 floor_n_01_1 - floor_n_01 rag_n_01_1 - rag_n_01 shelf_n_01_1 - shelf_n_01 soap_n_01_1 - soap_n_01)\n    (:init (dusty car_n_01_1) (not (soaked rag_n_01_1)) (onfloor bucket_n_01_1 floor_n_01_1) (onfloor car_n_01_1 floor_n_01_1) (ontop rag_n_01_1 shelf_n_01_1) (ontop soap_n_01_1 shelf_n_01_1))\n    (:goal (and (inside soap_n_01_1 bucket_n_01_1) (not (dusty car_n_01_1)) (inside rag_n_01_1 bucket_n_01_1)))\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_barbecue_grill_0_Ihlen_0_int_0_2021-09-10_16-02-39",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_barbecue_grill)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 - floor_n_01 grill_n_02_1 - grill_n_02 rag_n_01_1 - rag_n_01 sink_n_01_1 - sink_n_01 table_n_02_1 - table_n_02)\n    (:init (dusty grill_n_02_1) (onfloor grill_n_02_1 floor_n_01_1) (ontop rag_n_01_1 table_n_02_1) (stained grill_n_02_1))\n    (:goal (and (not (dusty grill_n_02_1)) (not (stained grill_n_02_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_bathrooms_0_Benevolence_0_int_1_2021-06-12_19-33-28",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_bathrooms)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bucket_n_01_1 - bucket_n_01 floor_n_01_1 - floor_n_01 rag_n_01_1 - rag_n_01 sink_n_01_1 - sink_n_01 soap_n_01_1 - soap_n_01 toilet_n_02_1 - toilet_n_02)\n    (:init (inside soap_n_01_1 sink_n_01_1) (not (soaked rag_n_01_1)) (onfloor agent_n_01_1 floor_n_01_1) (onfloor bucket_n_01_1 floor_n_01_1) (onfloor rag_n_01_1 floor_n_01_1) (stained floor_n_01_1) (stained sink_n_01_1) (stained toilet_n_02_1))\n    (:goal (and (not (stained toilet_n_02_1)) (not (stained floor_n_01_1)) (inside rag_n_01_1 bucket_n_01_1) (not (stained sink_n_01_1))))\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_bathtub_0_Pomaria_0_int_0_2021-09-10_16-22-10",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_bathtub)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bathtub_n_01_1 - bathtub_n_01 scrub_brush_n_01_1 - scrub_brush_n_01 sink_n_01_1 - sink_n_01)\n    (:init (inside scrub_brush_n_01_1 bathtub_n_01_1) (stained bathtub_n_01_1))\n    (:goal (not (stained bathtub_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_bedroom_0_Benevolence_2_int_0_2021-06-06_18-10-59",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_bedroom)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent apparel_n_01_1 apparel_n_01_2 - apparel_n_01 bed_n_01_1 - bed_n_01 cabinet_n_01_1 cabinet_n_01_2 - cabinet_n_01 floor_n_01_1 - floor_n_01 hand_towel_n_01_1 - hand_towel_n_01 painting_n_01_1 - painting_n_01 sheet_n_03_1 - sheet_n_03 vacuum_n_04_1 - vacuum_n_04)\n    (:init (dusty cabinet_n_01_1) (dusty cabinet_n_01_2) (not (dusty vacuum_n_04_1)) (onfloor hand_towel_n_01_1 floor_n_01_1) (onfloor sheet_n_03_1 floor_n_01_1) (onfloor vacuum_n_04_1 floor_n_01_1) (ontop apparel_n_01_1 bed_n_01_1) (ontop apparel_n_01_2 bed_n_01_1) (ontop painting_n_01_1 bed_n_01_1))\n    (:goal (and (not (dusty cabinet_n_01_1)) (inside apparel_n_01_2 cabinet_n_01_2) (nextto vacuum_n_04_1 bed_n_01_1) (ontop sheet_n_03_1 bed_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_vacuum)\n:parameters (?vacuum - vacuum_n_04 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_carpets_0_Wainscott_1_int_0_2021-09-11_01-12-41",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_carpets)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 floor_n_01_2 - floor_n_01 hand_towel_n_01_1 - hand_towel_n_01 sink_n_01_1 - sink_n_01)\n    (:init (onfloor agent_n_01_1 floor_n_01_1) (onfloor hand_towel_n_01_1 floor_n_01_2) (stained floor_n_01_1))\n    (:goal (not (stained floor_n_01_1)))\n)\nAction to be finished:\n(:action clean_stained_handowel)\n:parameters (?hand_towel - hand_towel_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_closet_0_Beechwood_1_int_0_2021-10-25_19-50-32",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_closet)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 cabinet_n_01_3 - cabinet_n_01 floor_n_01_1 - floor_n_01 hat_n_01_1 - hat_n_01 jewelry_n_01_1 jewelry_n_01_2 - jewelry_n_01 sandal_n_01_1 sandal_n_01_2 - sandal_n_01 towel_n_01_1 - towel_n_01 umbrella_n_01_1 - umbrella_n_01)\n    (:init (dusty cabinet_n_01_3) (dusty floor_n_01_1) (inside towel_n_01_1 cabinet_n_01_1) (onfloor hat_n_01_1 floor_n_01_1) (onfloor jewelry_n_01_1 floor_n_01_1) (onfloor jewelry_n_01_2 floor_n_01_1) (onfloor sandal_n_01_1 floor_n_01_1) (onfloor sandal_n_01_2 floor_n_01_1) (onfloor umbrella_n_01_1 floor_n_01_1))\n    (:goal (and (not (dusty cabinet_n_01_3)) (onfloor sandal_n_01_2 floor_n_01_1) (inside jewelry_n_01_2 cabinet_n_01_3) (not (dusty floor_n_01_1))))\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_towel)\n:parameters (?towel - towel_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_cupboards_0_Wainscott_1_int_1_2021-08-25_16-40-44",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_cupboards)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent \n    bed_n_01_1 - bed_n_01 \n    book_n_02_1 book_n_02_2 - book_n_02 \n    bucket_n_01_1 - bucket_n_01 \n    cabinet_n_01_1 cabinet_n_01_2 cabinet_n_01_3 - cabinet_n_01 \n    pen_n_01_1 - pen_n_01 \n    rag_n_01_1 - rag_n_01 \n    screwdriver_n_01_1 - screwdriver_n_01 \n    scrub_brush_n_01_1 - scrub_brush_n_01)\n    (:init (dusty cabinet_n_01_2) \n    (inside book_n_02_1 cabinet_n_01_1) \n    (inside book_n_02_2 cabinet_n_01_2) \n    (inside pen_n_01_1 cabinet_n_01_1) \n    (inside rag_n_01_1 cabinet_n_01_1) \n    (inside scrub_brush_n_01_1 cabinet_n_01_1) \n    (ontop bucket_n_01_1 bed_n_01_1))\n    (:goal (and \n    (inside pen_n_01_1 bucket_n_01_1) \n    (not (dusty cabinet_n_01_2)) \n    (not (inside book_n_02_1 cabinet_n_01_2)) \n    (not (inside book_n_02_2 cabinet_n_01_3))))\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_brush)\n:parameters (?scrub_brush - scrub_brush_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_floors_0_Merom_0_int_1_2021-06-23_16-12-28",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_floors)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent broom_n_01_1 - broom_n_01 dustpan_n_02_1 - dustpan_n_02 floor_n_01_1 - floor_n_01 scrub_brush_n_01_1 - scrub_brush_n_01 sink_n_01_1 - sink_n_01)\n    (:init (dusty floor_n_01_1) (onfloor agent_n_01_1 floor_n_01_1) (onfloor broom_n_01_1 floor_n_01_1) (onfloor cleansing_agent_n_01_1 floor_n_01_1) (onfloor dustpan_n_02_1 floor_n_01_1) (onfloor scrub_brush_n_01_1 floor_n_01_1) (stained floor_n_01_1))\n    (:goal (and (not (stained floor_n_01_1)) (not (dusty floor_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_brush)\n:parameters (?scrub_brush - scrub_brush_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_freezer_0_Pomaria_1_int_0_2021-10-26_12-59-25",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_freezer)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent electric_refrigerator_n_01_1 - electric_refrigerator_n_01 food_n_01_1 food_n_01_2 food_n_01_3 - food_n_01 sink_n_01_1 - sink_n_01 table_n_02_1 - table_n_02 towel_n_01_1 - towel_n_01)\n    (:init (inside food_n_01_1 electric_refrigerator_n_01_1) (inside food_n_01_2 electric_refrigerator_n_01_1) (inside food_n_01_3 electric_refrigerator_n_01_1) (ontop towel_n_01_1 table_n_02_1) (stained electric_refrigerator_n_01_1))\n    (:goal (and (not (inside food_n_01_2 electric_refrigerator_n_01_1)) (not (inside food_n_01_1 electric_refrigerator_n_01_1)) (not (stained electric_refrigerator_n_01_1)) (not (inside food_n_01_3 electric_refrigerator_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_towel)\n:parameters (?hand_towel - towel_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_garage_0_Ihlen_0_int_0_2021-08-24_17-40-48",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_garage)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bin_n_01_1 - bin_n_01 bottle_n_01_1 - bottle_n_01 cabinet_n_01_1 - cabinet_n_01 floor_n_01_1 - floor_n_01 newspaper_n_03_2 - newspaper_n_03 rag_n_01_1 - rag_n_01 sink_n_01_1 - sink_n_01 table_n_02_1 - table_n_02)\n    (:init (dusty cabinet_n_01_1) (onfloor bin_n_01_1 floor_n_01_1) (onfloor bottle_n_01_1 floor_n_01_1) (onfloor newspaper_n_03_2 floor_n_01_1) (ontop rag_n_01_1 table_n_02_1))\n    (:goal (and (inside newspaper_n_03_2 bin_n_01_1) (not (dusty cabinet_n_01_1)) (not (stained cabinet_n_01_1)) (ontop bottle_n_01_1 table_n_02_1)))\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_high_chair_0_Wainscott_0_int_0_2021-06-05_18-03-15",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_high_chair)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 floor_n_01_2 - floor_n_01 highchair_n_01_1 - highchair_n_01 piece_of_cloth_n_01_1 - piece_of_cloth_n_01)\n    (:init (dusty highchair_n_01_1) (inside piece_of_cloth_n_01_1 cabinet_n_01_1) (onfloor highchair_n_01_1 floor_n_01_2))\n    (:goal (not (dusty highchair_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_cloth)\n:parameters (?rag - piece_of_cloth_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_kitchen_cupboard_0_Pomaria_1_int_0_2021-10-26_13-05-36",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_kitchen_cupboard)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bowl_n_01_1 bowl_n_01_2 - bowl_n_01 cabinet_n_01_1 cabinet_n_01_2 - cabinet_n_01 countertop_n_01_1 - countertop_n_01 cup_n_01_1 cup_n_01_2 - cup_n_01 piece_of_cloth_n_01_1 - piece_of_cloth_n_01)\n    (:init (dusty cabinet_n_01_1) (dusty cabinet_n_01_2) (inside bowl_n_01_2 cabinet_n_01_2) (inside cup_n_01_1 cabinet_n_01_2) (inside cup_n_01_2 cabinet_n_01_1) (ontop bowl_n_01_1 countertop_n_01_1) (ontop piece_of_cloth_n_01_1 countertop_n_01_1))\n    (:goal (and (not (inside bowl_n_01_1 cabinet_n_01_2)) (inside bowl_n_01_2 cabinet_n_01_1) (not (dusty cabinet_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_cloth)\n:parameters (?rag - piece_of_cloth_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_microwave_oven_0_Benevolence_1_int_0_2021-09-11_01-27-10",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_microwave_oven)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent countertop_n_01_1 - countertop_n_01 microwave_n_02_1 - microwave_n_02 rag_n_01_1 - rag_n_01 sink_n_01_1 - sink_n_01)\n    (:init (dusty microwave_n_02_1) (ontop rag_n_01_1 countertop_n_01_1) (stained microwave_n_02_1))\n    (:goal (and (not (dusty microwave_n_02_1)) (not (stained microwave_n_02_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_out_drawers_0_Benevolence_1_int_0_2021-10-20_05-03-27",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_out_drawers)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bowl_n_01_1 bowl_n_01_2 - bowl_n_01 cabinet_n_01_1 cabinet_n_01_2 - cabinet_n_01 piece_of_cloth_n_01_1 - piece_of_cloth_n_01 sink_n_01_1 - sink_n_01 spoon_n_01_1 - spoon_n_01)\n    (:init (inside bowl_n_01_1 cabinet_n_01_1) (inside bowl_n_01_2 cabinet_n_01_1) (inside piece_of_cloth_n_01_1 cabinet_n_01_1) (inside spoon_n_01_1 cabinet_n_01_2))\n    (:goal (and (nextto piece_of_cloth_n_01_1 sink_n_01_1) (nextto spoon_n_01_1 sink_n_01_1) (nextto bowl_n_01_2 sink_n_01_1) (nextto bowl_n_01_1 sink_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_oven_0_Benevolence_1_int_0_2021-09-11_12-20-40",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_oven)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 oven_n_01_1 - oven_n_01 rag_n_01_1 rag_n_01_2 - rag_n_01 scrub_brush_n_01_1 - scrub_brush_n_01 sink_n_01_1 - sink_n_01)\n    (:init (inside rag_n_01_1 cabinet_n_01_1) (inside rag_n_01_2 cabinet_n_01_1) (inside scrub_brush_n_01_1 cabinet_n_01_1) (not (soaked rag_n_01_1)) (not (soaked rag_n_01_2)) (not (soaked scrub_brush_n_01_1)) (stained oven_n_01_1))\n    (:goal (and (soaked rag_n_01_2) (soaked scrub_brush_n_01_1) (not (stained oven_n_01_1)) (soaked rag_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_shoes_0_Pomaria_2_int_0_2021-09-11_13-59-22",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_shoes)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bed_n_01_1 - bed_n_01 floor_n_01_1 - floor_n_01 rag_n_01_1 - rag_n_01 shoe_n_01_1 shoe_n_01_2 shoe_n_01_3 shoe_n_01_4 - shoe_n_01 sink_n_01_1 - sink_n_01 towel_n_01_1 - towel_n_01)\n    (:init (dusty shoe_n_01_3) (dusty shoe_n_01_4) (not (soaked rag_n_01_1)) (onfloor towel_n_01_1 floor_n_01_1) (ontop rag_n_01_1 bed_n_01_1) (ontop shoe_n_01_1 bed_n_01_1) (ontop shoe_n_01_2 bed_n_01_1) (ontop shoe_n_01_3 bed_n_01_1) (ontop shoe_n_01_4 bed_n_01_1) (stained shoe_n_01_1) (stained shoe_n_01_2))\n    (:goal (and (not (dusty shoe_n_01_4)) (not (dusty shoe_n_01_2)) (not (stained shoe_n_01_1)) (not (stained shoe_n_01_3))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_sneakers_0_Pomaria_1_int_0_2021-10-26_13-36-08",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_sneakers)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent countertop_n_01_1 - countertop_n_01 floor_n_01_1 floor_n_01_2 - floor_n_01 gym_shoe_n_01_1 gym_shoe_n_01_4 - gym_shoe_n_01 sink_n_01_1 - sink_n_01 towel_n_01_1 - towel_n_01)\n    (:init (dusty gym_shoe_n_01_4) (not (stained towel_n_01_1)) (onfloor gym_shoe_n_01_1 floor_n_01_2) (onfloor gym_shoe_n_01_4 floor_n_01_2) (ontop towel_n_01_1 countertop_n_01_1) (stained gym_shoe_n_01_1))\n    (:goal (and (onfloor gym_shoe_n_01_1 floor_n_01_1) (not (stained gym_shoe_n_01_4)) (not (dusty gym_shoe_n_01_4)) (not (stained gym_shoe_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_onfloor)\n:parameters (?obj_in_hand - object ?floor - floor_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_towel)\n:parameters (?hand_towel - towel_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_towel)\n:parameters (?towel - towel_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_stove_0_Wainscott_0_int_0_2021-09-11_12-51-07",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_stove)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 dishtowel_n_01_1 - dishtowel_n_01 rag_n_01_1 - rag_n_01 sink_n_01_1 - sink_n_01 stove_n_01_1 - stove_n_01)\n    (:init (dusty stove_n_01_1) (inside dishtowel_n_01_1 cabinet_n_01_1) (inside rag_n_01_1 cabinet_n_01_1) (not (soaked dishtowel_n_01_1)) (not (soaked rag_n_01_1)) (not (stained rag_n_01_1)) (stained stove_n_01_1))\n    (:goal (and (nextto rag_n_01_1 sink_n_01_1) (not (dusty stove_n_01_1)) (nextto dishtowel_n_01_1 sink_n_01_1) (not (stained stove_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_table_after_clearing_0_Merom_1_int_0_2021-06-06_19-48-44",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_table_after_clearing)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 dishtowel_n_01_1 - dishtowel_n_01 sink_n_01_1 - sink_n_01 table_n_02_1 - table_n_02)\n    (:init (inside dishtowel_n_01_1 cabinet_n_01_1) (stained table_n_02_1))\n    (:goal (not (stained table_n_02_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_dishtowel)\n:parameters (?hand_towel - dishtowel_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_the_hot_tub_0_Ihlen_0_int_0_2021-08-24_22-19-07",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_the_hot_tub)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 - floor_n_01 pool_n_01_1 - pool_n_01 scrub_brush_n_01_1 - scrub_brush_n_01 sink_n_01_1 - sink_n_01)\n    (:init (onfloor agent_n_01_1 floor_n_01_1) (onfloor pool_n_01_1 floor_n_01_1) (onfloor scrub_brush_n_01_1 floor_n_01_1) (stained pool_n_01_1))\n    (:goal (and (onfloor pool_n_01_1 floor_n_01_1) (not (stained pool_n_01_1))))\n)\nAction to be finished:\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_the_pool_0_Ihlen_0_int_0_2021-06-01_15-30-31",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_the_pool)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent detergent_n_02_1 - detergent_n_02 floor_n_01_1 - floor_n_01 pool_n_01_1 - pool_n_01 scrub_brush_n_01_1 - scrub_brush_n_01 shelf_n_01_1 - shelf_n_01 sink_n_01_1 - sink_n_01)\n    (:init (onfloor agent_n_01_1 floor_n_01_1) (onfloor detergent_n_02_1 floor_n_01_1) (onfloor pool_n_01_1 floor_n_01_1) (onfloor scrub_brush_n_01_1 floor_n_01_1) (stained pool_n_01_1))\n    (:goal (and (not (stained pool_n_01_1)) (onfloor pool_n_01_1 floor_n_01_1) (ontop scrub_brush_n_01_1 shelf_n_01_1) (onfloor detergent_n_02_1 floor_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_toilet_0_Merom_0_int_1_2021-06-23_17-35-48",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_toilet)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent detergent_n_02_1 - detergent_n_02 floor_n_01_1 - floor_n_01 scrub_brush_n_01_1 - scrub_brush_n_01 sink_n_01_1 - sink_n_01 toilet_n_02_1 - toilet_n_02)\n    (:init (onfloor agent_n_01_1 floor_n_01_1) (onfloor detergent_n_02_1 floor_n_01_1) (onfloor scrub_brush_n_01_1 floor_n_01_1) (stained toilet_n_02_1))\n    (:goal (and (onfloor detergent_n_02_1 floor_n_01_1) (not (stained toilet_n_02_1)) (onfloor scrub_brush_n_01_1 floor_n_01_1)))\n)\nAction to be finished:\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_up_after_a_meal_0_Wainscott_0_int_0_2021-10-20_05-33-24",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_up_after_a_meal)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bowl_n_01_1 bowl_n_01_2 - bowl_n_01 cup_n_01_1 cup_n_01_2 - cup_n_01 dishwasher_n_01_1 - dishwasher_n_01 plate_n_04_1 plate_n_04_2 plate_n_04_3 plate_n_04_4 - plate_n_04 sack_n_01_1 - sack_n_01 sink_n_01_1 - sink_n_01 table_n_02_1 - table_n_02)\n    (:init (ontop bowl_n_01_1 table_n_02_1) (ontop bowl_n_01_2 table_n_02_1) (ontop cup_n_01_1 table_n_02_1) (ontop cup_n_01_2 table_n_02_1) (ontop plate_n_04_1 table_n_02_1) (ontop plate_n_04_2 table_n_02_1) (ontop plate_n_04_3 table_n_02_1) (ontop plate_n_04_4 table_n_02_1) (ontop sack_n_01_1 table_n_02_1) (stained bowl_n_01_1) (stained bowl_n_01_2) (stained plate_n_04_4) (stained table_n_02_1))\n    (:goal (and (not (stained bowl_n_01_2)) (not (stained plate_n_04_4)) (not (stained table_n_02_1)) (not (stained bowl_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_dishwasher)\n:parameters (?dishwasher - dishwasher_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_up_refrigerator_0_Wainscott_0_int_1_2021-06-23_17-46-01",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_up_refrigerator)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bowl_n_01_1 - bowl_n_01 cabinet_n_01_1 - cabinet_n_01 countertop_n_01_1 - countertop_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 rag_n_01_1 rag_n_01_2 - rag_n_01 sink_n_01_1 - sink_n_01 soap_n_01_1 - soap_n_01 tray_n_01_1 tray_n_01_2 - tray_n_01)\n    (:init (inside bowl_n_01_1 electric_refrigerator_n_01_1) (inside rag_n_01_1 cabinet_n_01_1) (inside rag_n_01_2 cabinet_n_01_1) (inside tray_n_01_1 electric_refrigerator_n_01_1) (inside tray_n_01_2 electric_refrigerator_n_01_1) (not (soaked rag_n_01_1)) (not (soaked rag_n_01_2)) (ontop soap_n_01_1 countertop_n_01_1) (stained electric_refrigerator_n_01_1) (stained tray_n_01_1))\n    (:goal (and (inside tray_n_01_1 electric_refrigerator_n_01_1) (inside soap_n_01_1 sink_n_01_1) (nextto rag_n_01_2 sink_n_01_1) (not (stained electric_refrigerator_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_up_the_kitchen_only_0_Pomaria_1_int_0_2021-10-26_00-50-16",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_up_the_kitchen_only)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent apple_n_01_1 - apple_n_01 blender_n_01_1 - blender_n_01 cabinet_n_01_1 - cabinet_n_01 casserole_n_02_1 - casserole_n_02 countertop_n_01_1 - countertop_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 floor_n_01_1 - floor_n_01 plate_n_04_1 - plate_n_04 rag_n_01_1 - rag_n_01 sink_n_01_1 - sink_n_01 vegetable_oil_n_01_1 - vegetable_oil_n_01)\n    (:init (inside apple_n_01_1 electric_refrigerator_n_01_1) (inside casserole_n_02_1 electric_refrigerator_n_01_1) (inside plate_n_04_1 electric_refrigerator_n_01_1) (inside rag_n_01_1 cabinet_n_01_1) (inside vegetable_oil_n_01_1 electric_refrigerator_n_01_1) (not (soaked rag_n_01_1)) (onfloor blender_n_01_1 floor_n_01_1) (stained blender_n_01_1))\n    (:goal (and (inside casserole_n_02_1 electric_refrigerator_n_01_1) (ontop blender_n_01_1 countertop_n_01_1) (inside rag_n_01_1 sink_n_01_1) (inside apple_n_01_1 electric_refrigerator_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "cleaning_windows_0_Wainscott_0_int_0_2021-05-23_23-07-05",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem cleaning_windows)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 rag_n_01_1 rag_n_01_2 - rag_n_01 sink_n_01_1 - sink_n_01 towel_n_01_1 towel_n_01_2 - towel_n_01 window_n_01_1 window_n_01_2 - window_n_01)\n    (:init (dusty window_n_01_1) (dusty window_n_01_2) (inside rag_n_01_1 cabinet_n_01_1) (inside rag_n_01_2 cabinet_n_01_1) (inside towel_n_01_1 cabinet_n_01_1) (inside towel_n_01_2 cabinet_n_01_1) (not (dusty sink_n_01_1)) (not (soaked rag_n_01_1)) (not (soaked rag_n_01_2)))\n    (:goal (and (soaked rag_n_01_1) (soaked rag_n_01_2) (not (dusty window_n_01_2)) (not (dusty window_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "clearing_the_table_after_dinner_0_Ihlen_0_int_0_2021-10-25_23-01-51",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem clearing_the_table_after_dinner)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bowl_n_01_1 bowl_n_01_2 bowl_n_01_4 - bowl_n_01 bucket_n_01_1 bucket_n_01_2 - bucket_n_01 catsup_n_01_1 - catsup_n_01 floor_n_01_1 - floor_n_01 table_n_02_1 - table_n_02)\n    (:init (onfloor bucket_n_01_1 floor_n_01_1) (onfloor bucket_n_01_2 floor_n_01_1) (ontop bowl_n_01_1 table_n_02_1) (ontop bowl_n_01_2 table_n_02_1) (ontop bowl_n_01_4 table_n_02_1) (ontop catsup_n_01_1 table_n_02_1))\n    (:goal (and (inside bowl_n_01_4 bucket_n_01_1) (inside bowl_n_01_1 bucket_n_01_2) (inside catsup_n_01_1 bucket_n_01_2) (inside bowl_n_01_2 bucket_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "collecting_aluminum_cans_0_Ihlen_1_int_0_2021-06-06_20-13-28",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem collecting_aluminum_cans)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bed_n_01_1 - bed_n_01 bucket_n_01_1 - bucket_n_01 floor_n_01_1 - floor_n_01 pop_n_02_1 pop_n_02_4 pop_n_02_5 pop_n_02_6 - pop_n_02)\n    (:init (onfloor pop_n_02_4 floor_n_01_1) (onfloor pop_n_02_5 floor_n_01_1) (onfloor pop_n_02_6 floor_n_01_1) (ontop bucket_n_01_1 bed_n_01_1) (ontop pop_n_02_1 bed_n_01_1))\n    (:goal (and (inside pop_n_02_1 bucket_n_01_1) (inside pop_n_02_5 bucket_n_01_1) (inside pop_n_02_4 bucket_n_01_1) (inside pop_n_02_6 bucket_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "collect_misplaced_items_0_Wainscott_0_int_1_2021-10-26_18-48-11",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem collect_misplaced_items)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 floor_n_01_1 - floor_n_01 necklace_n_01_1 - necklace_n_01 notebook_n_01_1 - notebook_n_01 sock_n_01_1 sock_n_01_2 - sock_n_01 sofa_n_01_1 - sofa_n_01 table_n_02_2 - table_n_02)\n    (:init (inside necklace_n_01_1 cabinet_n_01_1) (onfloor sock_n_01_2 floor_n_01_1) (ontop sock_n_01_1 sofa_n_01_1) (under notebook_n_01_1 table_n_02_2))\n    (:goal (and (ontop sock_n_01_1 table_n_02_2) (ontop necklace_n_01_1 table_n_02_2) (ontop sock_n_01_2 table_n_02_2) (ontop notebook_n_01_1 table_n_02_2)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "defrosting_freezer_0_Beechwood_0_int_0_2021-10-25_23-10-43",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem defrosting_freezer)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bucket_n_01_1 - bucket_n_01 countertop_n_01_1 - countertop_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 floor_n_01_1 - floor_n_01 food_n_02_1 food_n_02_2 food_n_02_3 - food_n_02 rag_n_01_1 - rag_n_01 receptacle_n_01_1 - receptacle_n_01 scraper_n_01_1 - scraper_n_01 towel_n_01_1 - towel_n_01)\n    (:init (inside food_n_02_1 electric_refrigerator_n_01_1) (inside food_n_02_2 electric_refrigerator_n_01_1) (inside food_n_02_3 electric_refrigerator_n_01_1) (not (stained towel_n_01_1)) (onfloor bucket_n_01_1 floor_n_01_1) (onfloor receptacle_n_01_1 floor_n_01_1) (ontop rag_n_01_1 countertop_n_01_1) (ontop scraper_n_01_1 countertop_n_01_1) (ontop towel_n_01_1 countertop_n_01_1))\n    (:goal (and (ontop scraper_n_01_1 electric_refrigerator_n_01_1) (ontop towel_n_01_1 countertop_n_01_1) (inside food_n_02_1 bucket_n_01_1) (nextto receptacle_n_01_1 electric_refrigerator_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "filling_an_Easter_basket_0_Benevolence_1_int_1_2021-09-10_00-09-54",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem filling_an_Easter_basket)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent basket_n_01_1 basket_n_01_2 - basket_n_01 bow_n_08_2 - bow_n_08 cabinet_n_01_2 - cabinet_n_01 candy_n_01_1 candy_n_01_2 - candy_n_01 countertop_n_01_1 - countertop_n_01 egg_n_02_1 - egg_n_02 electric_refrigerator_n_01_1 - electric_refrigerator_n_01)\n    (:init (cooked egg_n_02_1) (inside bow_n_08_2 cabinet_n_01_2) (inside egg_n_02_1 electric_refrigerator_n_01_1) (ontop basket_n_01_1 countertop_n_01_1) (ontop basket_n_01_2 countertop_n_01_1) (ontop candy_n_01_1 electric_refrigerator_n_01_1) (ontop candy_n_01_2 electric_refrigerator_n_01_1))\n    (:goal (and (inside egg_n_02_1 basket_n_01_1) (inside candy_n_01_2 basket_n_01_1) (ontop bow_n_08_2 basket_n_01_1) (inside candy_n_01_1 basket_n_01_2)))\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "filling_a_Christmas_stocking_0_Rs_int_0_2021-06-04_18-47-42",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem filling_a_Christmas_stocking)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 candy_n_01_4 - candy_n_01 cube_n_05_1 cube_n_05_3 - cube_n_05 floor_n_01_1 - floor_n_01 pen_n_01_2 - pen_n_01 stocking_n_01_1 stocking_n_01_2 stocking_n_01_4 - stocking_n_01)\n    (:init (inside candy_n_01_4 cabinet_n_01_1) (inside pen_n_01_2 cabinet_n_01_1) (onfloor cube_n_05_1 floor_n_01_1) (onfloor cube_n_05_3 floor_n_01_1) (onfloor stocking_n_01_1 floor_n_01_1) (onfloor stocking_n_01_2 floor_n_01_1) (onfloor stocking_n_01_4 floor_n_01_1))\n    (:goal (and (inside pen_n_01_2 stocking_n_01_2) (inside candy_n_01_4 stocking_n_01_4) (inside cube_n_05_3 stocking_n_01_4) (inside cube_n_05_1 stocking_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "installing_alarms_0_Merom_1_int_0_2021-05-23_23-02-24",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem installing_alarms)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent alarm_n_02_1 alarm_n_02_2 - alarm_n_02 table_n_02_1 table_n_02_2 - table_n_02)\n    (:init (not (toggled_on alarm_n_02_1)) (not (toggled_on alarm_n_02_2)) (ontop alarm_n_02_1 table_n_02_2) (ontop alarm_n_02_2 table_n_02_2))\n    (:goal (and (toggled_on alarm_n_02_2) (toggled_on alarm_n_02_1) (ontop alarm_n_02_1 table_n_02_2) (ontop alarm_n_02_2 table_n_02_1)))\n)\nAction to be finished:\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "installing_a_fax_machine_0_Beechwood_0_int_0_2021-10-25_20-22-22",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem installing_a_fax_machine)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent facsimile_n_02_1 - facsimile_n_02 floor_n_01_1 - floor_n_01 table_n_02_1 - table_n_02)\n    (:init (not (toggled_on facsimile_n_02_1)) (onfloor facsimile_n_02_1 floor_n_01_1))\n    (:goal (and (toggled_on facsimile_n_02_1) (ontop facsimile_n_02_1 table_n_02_1)))\n)\nAction to be finished:\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "installing_a_modem_0_Beechwood_0_int_0_2021-10-25_20-28-55",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem installing_a_modem)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent modem_n_01_1 - modem_n_01 table_n_02_1 - table_n_02)\n    (:init (not (toggled_on modem_n_01_1)) (ontop modem_n_01_1 table_n_02_1))\n    (:goal (and (under modem_n_01_1 table_n_02_1) (toggled_on modem_n_01_1)))\n)\nAction to be finished:\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_under)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "installing_a_printer_0_Pomaria_0_int_0_2021-06-08_18-33-07",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem installing_a_printer)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 - floor_n_01 printer_n_03_1 - printer_n_03 table_n_02_1 - table_n_02)\n    (:init (not (toggled_on printer_n_03_1)) (onfloor printer_n_03_1 floor_n_01_1))\n    (:goal (and (ontop printer_n_03_1 table_n_02_1) (toggled_on printer_n_03_1)))\n)\nAction to be finished:\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "installing_a_scanner_0_Pomaria_0_int_0_2021-06-08_18-34-59",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem installing_a_scanner)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent scanner_n_02_1 - scanner_n_02 table_n_02_1 - table_n_02)\n    (:init (not (toggled_on scanner_n_02_1)) (ontop scanner_n_02_1 table_n_02_1))\n    (:goal (and (toggled_on scanner_n_02_1) (under scanner_n_02_1 table_n_02_1)))\n)\nAction to be finished:\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_under)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "laying_tile_floors_0_Beechwood_0_int_0_2021-10-26_17-26-23",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem laying_tile_floors)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 floor_n_01_2 - floor_n_01 tile_n_01_1 tile_n_01_2 tile_n_01_3 tile_n_01_4 - tile_n_01)\n    (:init (onfloor tile_n_01_1 floor_n_01_1) (onfloor tile_n_01_2 floor_n_01_1) (onfloor tile_n_01_3 floor_n_01_1) (onfloor tile_n_01_4 floor_n_01_1))\n    (:goal (and (onfloor tile_n_01_3 floor_n_01_2) (onfloor tile_n_01_4 floor_n_01_2) (onfloor tile_n_01_2 floor_n_01_2) (onfloor tile_n_01_1 floor_n_01_2)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_onfloor)\n:parameters (?obj_in_hand - object ?floor - floor_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "laying_wood_floors_0_Pomaria_1_int_0_2021-10-25_20-46-59",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem laying_wood_floors)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 floor_n_01_2 - floor_n_01 plywood_n_01_1 plywood_n_01_2 plywood_n_01_3 plywood_n_01_4 - plywood_n_01)\n    (:init (onfloor plywood_n_01_1 floor_n_01_1) (onfloor plywood_n_01_2 floor_n_01_1) (onfloor plywood_n_01_3 floor_n_01_1) (onfloor plywood_n_01_4 floor_n_01_1))\n    (:goal (and (nextto plywood_n_01_3 plywood_n_01_2) (nextto plywood_n_01_2 plywood_n_01_2) (onfloor plywood_n_01_4 floor_n_01_2) (onfloor plywood_n_01_1 floor_n_01_2)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_onfloor)\n:parameters (?obj_in_hand - object ?floor - floor_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "loading_the_dishwasher_0_Benevolence_1_int_0_2021-10-20_06-10-42",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem loading_the_dishwasher)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bowl_n_01_2 - bowl_n_01 countertop_n_01_1 - countertop_n_01 dishwasher_n_01_1 - dishwasher_n_01 plate_n_04_1 plate_n_04_2 plate_n_04_3 - plate_n_04)\n    (:init (ontop bowl_n_01_2 countertop_n_01_1) (ontop plate_n_04_1 countertop_n_01_1) (ontop plate_n_04_2 countertop_n_01_1) (ontop plate_n_04_3 countertop_n_01_1) (stained bowl_n_01_2) (stained plate_n_04_1) (stained plate_n_04_2) (stained plate_n_04_3))\n    (:goal (and (inside bowl_n_01_2 dishwasher_n_01_1) (inside plate_n_04_2 dishwasher_n_01_1) (inside plate_n_04_3 dishwasher_n_01_1) (inside plate_n_04_1 dishwasher_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "locking_every_door_0_Merom_1_int_0_2021-10-20_05-53-14",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem locking_every_door)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent door_n_01_1 door_n_01_2 - door_n_01)\n    (:init (open door_n_01_1) (open door_n_01_2))\n    (:goal (and (not (open door_n_01_1)) (not (open door_n_01_2))))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "locking_every_window_0_Merom_1_int_0_2021-11-01_14-51-10",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem locking_every_window)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent window_n_01_1 window_n_01_2 window_n_01_3 window_n_01_4 - window_n_01)\n    (:init (open window_n_01_1) (open window_n_01_2) (open window_n_01_3) (open window_n_01_4))\n    (:goal (and (not (open window_n_01_4)) (not (open window_n_01_1)) (not (open window_n_01_2)) (not (open window_n_01_3))))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action close)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "making_tea_0_Wainscott_0_int_0_2021-10-26_12-49-48",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem making_tea)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 knife_n_01_1 - knife_n_01 lemon_n_01_1 - lemon_n_01 stove_n_01_1 - stove_n_01 tea_bag_n_01_1 - tea_bag_n_01 teapot_n_01_1 - teapot_n_01)\n    (:init (inside knife_n_01_1 cabinet_n_01_1) (inside lemon_n_01_1 electric_refrigerator_n_01_1) (inside tea_bag_n_01_1 cabinet_n_01_1) (inside teapot_n_01_1 cabinet_n_01_1))\n    (:goal (and (ontop teapot_n_01_1 stove_n_01_1) (soaked tea_bag_n_01_1) (sliced lemon_n_01_1) (toggled_on stove_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action slice)\n:parameters (?obj - object ?knife - knife_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak_teapot)\n:parameters (?obj1 - object ?agent - agent ?teapot - teapot_n_01)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "mopping_floors_0_Benevolence_2_int_0_2021-10-25_21-01-58",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem mopping_floors)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent broom_n_01_1 - broom_n_01 bucket_n_01_1 - bucket_n_01 floor_n_01_1 floor_n_01_2 - floor_n_01 piece_of_cloth_n_01_1 - piece_of_cloth_n_01 sink_n_01_1 - sink_n_01 soap_n_01_1 - soap_n_01)\n    (:init (onfloor agent_n_01_1 floor_n_01_1) (onfloor broom_n_01_1 floor_n_01_2) (onfloor bucket_n_01_1 floor_n_01_1) (onfloor piece_of_cloth_n_01_1 floor_n_01_1) (onfloor soap_n_01_1 floor_n_01_1) (stained floor_n_01_1))\n    (:goal (and (nextto broom_n_01_1 sink_n_01_1) (inside soap_n_01_1 bucket_n_01_1) (nextto bucket_n_01_1 sink_n_01_1) (not (stained floor_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_cloth)\n:parameters (?rag - piece_of_cloth_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "moving_boxes_to_storage_0_Merom_0_int_0_2021-06-11_20-04-35",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem moving_boxes_to_storage)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent carton_n_02_1 carton_n_02_2 - carton_n_02 floor_n_01_1 floor_n_01_2 - floor_n_01)\n    (:init (onfloor agent_n_01_1 floor_n_01_2) (onfloor carton_n_02_1 floor_n_01_1) (onfloor carton_n_02_2 floor_n_01_1))\n    (:goal (and (ontop carton_n_02_2 carton_n_02_1) (onfloor carton_n_02_1 floor_n_01_2)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_onfloor)\n:parameters (?obj_in_hand - object ?floor - floor_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "opening_packages_0_Benevolence_2_int_0_2021-10-25_21-06-42",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem opening_packages)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 - floor_n_01 package_n_02_1 package_n_02_2 - package_n_02)\n    (:init (not (open package_n_02_1)) (not (open package_n_02_2)) (onfloor package_n_02_1 floor_n_01_1) (onfloor package_n_02_2 floor_n_01_1))\n    (:goal (and (open package_n_02_2) (open package_n_02_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "opening_presents_0_Benevolence_2_int_0_2021-10-25_21-10-48",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem opening_presents)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 - floor_n_01 package_n_02_1 package_n_02_2 - package_n_02)\n    (:init (not (open package_n_02_1)) (not (open package_n_02_2)) (onfloor package_n_02_1 floor_n_01_1) (onfloor package_n_02_2 floor_n_01_1))\n    (:goal (and (open package_n_02_1) (open package_n_02_2)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "organizing_boxes_in_garage_0_Ihlen_0_int_0_2021-08-24_22-59-54",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem organizing_boxes_in_garage)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent ball_n_01_1 ball_n_01_2 - ball_n_01 carton_n_02_1 carton_n_02_2 - carton_n_02 floor_n_01_1 - floor_n_01 plate_n_04_2 - plate_n_04 saucepan_n_01_1 - saucepan_n_01 shelf_n_01_1 - shelf_n_01)\n    (:init (inside plate_n_04_2 shelf_n_01_1) (inside saucepan_n_01_1 shelf_n_01_1) (onfloor agent_n_01_1 floor_n_01_1) (onfloor ball_n_01_1 floor_n_01_1) (onfloor ball_n_01_2 floor_n_01_1) (onfloor carton_n_02_1 floor_n_01_1) (onfloor carton_n_02_2 floor_n_01_1))\n    (:goal (and (inside ball_n_01_1 carton_n_02_1) (inside plate_n_04_2 carton_n_02_1) (inside saucepan_n_01_1 carton_n_02_1) (onfloor carton_n_02_1 floor_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "organizing_file_cabinet_0_Pomaria_0_int_0_2021-06-08_15-27-20",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem organizing_file_cabinet)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 chair_n_01_1 - chair_n_01 document_n_01_1 document_n_01_2 document_n_01_3 document_n_01_4 - document_n_01 floor_n_01_1 - floor_n_01 folder_n_02_1 folder_n_02_2 - folder_n_02 marker_n_03_1 - marker_n_03 table_n_02_1 - table_n_02)\n    (:init (inside document_n_01_2 cabinet_n_01_1) (inside document_n_01_4 cabinet_n_01_1) (onfloor folder_n_02_2 floor_n_01_1) (ontop document_n_01_1 table_n_02_1) (ontop document_n_01_3 table_n_02_1) (ontop folder_n_02_1 table_n_02_1) (ontop marker_n_03_1 chair_n_01_1))\n    (:goal (and (ontop marker_n_03_1 table_n_02_1) (inside document_n_01_1 cabinet_n_01_1) (inside folder_n_02_2 cabinet_n_01_1) (inside document_n_01_4 cabinet_n_01_1)))\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "organizing_school_stuff_0_Wainscott_1_int_0_2021-08-24_22-56-24",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem organizing_school_stuff)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent backpack_n_01_1 - backpack_n_01 bed_n_01_1 - bed_n_01 book_n_02_1 - book_n_02 floor_n_01_1 - floor_n_01 folder_n_02_1 - folder_n_02 highlighter_n_02_1 - highlighter_n_02 pen_n_01_1 - pen_n_01 pencil_n_01_1 - pencil_n_01)\n    (:init (onfloor backpack_n_01_1 floor_n_01_1) (onfloor pen_n_01_1 floor_n_01_1) (ontop book_n_02_1 bed_n_01_1) (ontop folder_n_02_1 bed_n_01_1) (ontop highlighter_n_02_1 bed_n_01_1) (ontop pencil_n_01_1 bed_n_01_1))\n    (:goal (and (nextto book_n_02_1 backpack_n_01_1) (nextto folder_n_02_1 backpack_n_01_1) (inside pen_n_01_1 backpack_n_01_1) (ontop backpack_n_01_1 bed_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "packing_adult_s_bags_0_Ihlen_1_int_0_2021-10-26_09-54-15",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem packing_adult_s_bags)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent backpack_n_01_1 - backpack_n_01 bed_n_01_1 - bed_n_01 floor_n_01_1 - floor_n_01 jewelry_n_01_1 jewelry_n_01_2 - jewelry_n_01 makeup_n_01_1 - makeup_n_01 mouse_n_04_1 - mouse_n_04)\n    (:init (onfloor backpack_n_01_1 floor_n_01_1) (onfloor jewelry_n_01_1 floor_n_01_1) (onfloor jewelry_n_01_2 floor_n_01_1) (ontop makeup_n_01_1 bed_n_01_1) (ontop mouse_n_04_1 bed_n_01_1))\n    (:goal (and (inside makeup_n_01_1 backpack_n_01_1) (inside mouse_n_04_1 backpack_n_01_1) (inside jewelry_n_01_2 backpack_n_01_1) (inside jewelry_n_01_1 backpack_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "packing_bags_or_suitcase_0_Merom_1_int_0_2021-10-26_10-04-07",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem packing_bags_or_suitcase)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent backpack_n_01_1 - backpack_n_01 bed_n_01_1 - bed_n_01 floor_n_01_1 - floor_n_01 hardback_n_01_1 - hardback_n_01 shampoo_n_01_1 - shampoo_n_01 underwear_n_01_1 - underwear_n_01)\n    (:init (onfloor agent_n_01_1 floor_n_01_1) (onfloor backpack_n_01_1 floor_n_01_1) (ontop hardback_n_01_1 bed_n_01_1) (ontop shampoo_n_01_1 bed_n_01_1) (ontop underwear_n_01_1 bed_n_01_1))\n    (:goal (and (onfloor backpack_n_01_1 floor_n_01_1) (inside shampoo_n_01_1 backpack_n_01_1) (inside underwear_n_01_1 backpack_n_01_1) (inside hardback_n_01_1 backpack_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "packing_boxes_for_household_move_or_trip_0_Ihlen_1_int_0_2021-06-08_19-16-19",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem packing_boxes_for_household_move_or_trip)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent carton_n_02_1 carton_n_02_2 - carton_n_02 dishtowel_n_01_1 - dishtowel_n_01 floor_n_01_1 - floor_n_01 plate_n_04_2 - plate_n_04 shirt_n_01_1 shirt_n_01_2 - shirt_n_01)\n    (:init (onfloor carton_n_02_1 floor_n_01_1) (onfloor carton_n_02_2 floor_n_01_1) (onfloor dishtowel_n_01_1 floor_n_01_1) (onfloor plate_n_04_2 floor_n_01_1) (onfloor shirt_n_01_1 floor_n_01_1) (onfloor shirt_n_01_2 floor_n_01_1))\n    (:goal (and (inside shirt_n_01_1 carton_n_02_1) (inside plate_n_04_2 carton_n_02_2) (inside dishtowel_n_01_1 carton_n_02_2) (inside shirt_n_01_2 carton_n_02_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "packing_car_for_trip_0_Ihlen_0_int_0_2021-10-26_10-27-23",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem packing_car_for_trip)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent briefcase_n_01_1 - briefcase_n_01 car_n_01_1 - car_n_01 duffel_bag_n_01_1 - duffel_bag_n_01 floor_n_01_1 floor_n_01_2 - floor_n_01 headset_n_01_1 - headset_n_01 pencil_box_n_01_1 - pencil_box_n_01 table_n_02_1 - table_n_02)\n    (:init (onfloor briefcase_n_01_1 floor_n_01_2) (onfloor car_n_01_1 floor_n_01_1) (onfloor duffel_bag_n_01_1 floor_n_01_2) (ontop headset_n_01_1 table_n_02_1) (ontop pencil_box_n_01_1 table_n_02_1))\n    (:goal (and (inside briefcase_n_01_1 car_n_01_1) (inside duffel_bag_n_01_1 car_n_01_1) (inside pencil_box_n_01_1 car_n_01_1) (inside headset_n_01_1 car_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "packing_child_s_bag_0_Beechwood_1_int_0_2021-10-26_10-33-11",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem packing_child_s_bag)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent apple_n_01_1 - apple_n_01 backpack_n_01_1 - backpack_n_01 bed_n_01_1 - bed_n_01 bracelet_n_02_1 - bracelet_n_02 earphone_n_01_1 - earphone_n_01 floor_n_01_1 - floor_n_01 notebook_n_01_1 - notebook_n_01 sunglass_n_01_1 - sunglass_n_01)\n    (:init (onfloor backpack_n_01_1 floor_n_01_1) (onfloor notebook_n_01_1 floor_n_01_1) (ontop apple_n_01_1 bed_n_01_1) (ontop bracelet_n_02_1 bed_n_01_1) (ontop earphone_n_01_1 bed_n_01_1) (ontop sunglass_n_01_1 bed_n_01_1))\n    (:goal (and (nextto backpack_n_01_1 bed_n_01_1) (inside sunglass_n_01_1 backpack_n_01_1) (inside notebook_n_01_1 backpack_n_01_1) (inside bracelet_n_02_1 backpack_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "packing_food_for_work_0_Ihlen_1_int_0_2021-06-08_19-36-15",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem packing_food_for_work)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent apple_n_01_1 - apple_n_01 cabinet_n_01_1 - cabinet_n_01 carton_n_02_1 - carton_n_02 countertop_n_01_1 - countertop_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 floor_n_01_1 - floor_n_01 juice_n_01_1 - juice_n_01 sandwich_n_01_1 - sandwich_n_01 snack_food_n_01_1 - snack_food_n_01)\n    (:init (inside sandwich_n_01_1 electric_refrigerator_n_01_1) (inside snack_food_n_01_1 cabinet_n_01_1) (onfloor carton_n_02_1 floor_n_01_1) (ontop apple_n_01_1 countertop_n_01_1) (ontop juice_n_01_1 countertop_n_01_1))\n    (:goal (and (inside snack_food_n_01_1 carton_n_02_1) (inside sandwich_n_01_1 carton_n_02_1) (ontop carton_n_02_1 countertop_n_01_1) (inside apple_n_01_1 carton_n_02_1)))\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "packing_lunches_0_Beechwood_0_int_0_2021-10-26_11-03-14",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem packing_lunches)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent apple_n_01_1 - apple_n_01 carton_n_02_1 carton_n_02_2 - carton_n_02 countertop_n_01_1 - countertop_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 floor_n_01_2 - floor_n_01 juice_n_01_1 - juice_n_01 pop_n_02_1 - pop_n_02 sandwich_n_01_1 - sandwich_n_01 table_n_02_1 - table_n_02)\n    (:init (inside sandwich_n_01_1 electric_refrigerator_n_01_1) (onfloor carton_n_02_1 floor_n_01_2) (onfloor carton_n_02_2 floor_n_01_2) (ontop apple_n_01_1 countertop_n_01_1) (ontop juice_n_01_1 table_n_02_1) (ontop pop_n_02_1 table_n_02_1))\n    (:goal (and (inside apple_n_01_1 carton_n_02_1) (not (inside sandwich_n_01_1 carton_n_02_2)) (inside juice_n_01_1 carton_n_02_2) (inside pop_n_02_1 carton_n_02_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "packing_picnics_0_Wainscott_0_int_0_2021-10-26_11-07-29",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem packing_picnics)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent carton_n_02_2 carton_n_02_3 - carton_n_02 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 floor_n_01_2 - floor_n_01 grape_n_01_3 - grape_n_01 pop_n_02_2 - pop_n_02 strawberry_n_01_1 strawberry_n_01_4 - strawberry_n_01)\n    (:init (inside grape_n_01_3 electric_refrigerator_n_01_1) (inside pop_n_02_2 electric_refrigerator_n_01_1) (inside strawberry_n_01_1 electric_refrigerator_n_01_1) (inside strawberry_n_01_4 electric_refrigerator_n_01_1) (onfloor carton_n_02_2 floor_n_01_2) (onfloor carton_n_02_3 floor_n_01_2))\n    (:goal (and (inside strawberry_n_01_1 carton_n_02_2) (inside grape_n_01_3 carton_n_02_2) (inside pop_n_02_2 carton_n_02_3) (inside strawberry_n_01_4 carton_n_02_2)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "picking_up_take-out_food_0_Ihlen_1_int_0_2021-06-10_22-09-43",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem picking_up_take-out_food)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent carton_n_02_1 - carton_n_02 floor_n_01_1 - floor_n_01 hamburger_n_01_1 - hamburger_n_01 sushi_n_01_1 - sushi_n_01 table_n_02_1 - table_n_02)\n    (:init (inside hamburger_n_01_1 carton_n_02_1) (inside sushi_n_01_1 carton_n_02_1) (onfloor carton_n_02_1 floor_n_01_1))\n    (:goal (and (ontop carton_n_02_1 table_n_02_1) (inside hamburger_n_01_1 carton_n_02_1) (inside sushi_n_01_1 carton_n_02_1)))\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "picking_up_trash_0_Beechwood_0_int_1_2021-10-26_14-06-49",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem picking_up_trash)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent ashcan_n_01_1 - ashcan_n_01 floor_n_01_1 floor_n_01_2 - floor_n_01 pad_n_01_1 pad_n_01_3 - pad_n_01 pop_n_02_1 pop_n_02_2 - pop_n_02)\n    (:init (onfloor ashcan_n_01_1 floor_n_01_2) (onfloor pad_n_01_1 floor_n_01_2) (onfloor pad_n_01_3 floor_n_01_1) (onfloor pop_n_02_1 floor_n_01_1) (onfloor pop_n_02_2 floor_n_01_1))\n    (:goal (and (inside pad_n_01_3 ashcan_n_01_1) (inside pop_n_02_2 ashcan_n_01_1) (inside pop_n_02_1 ashcan_n_01_1) (inside pad_n_01_1 ashcan_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "polishing_furniture_0_Ihlen_0_int_0_2021-10-26_11-35-40",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem polishing_furniture)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent rag_n_01_1 - rag_n_01 shelf_n_01_1 - shelf_n_01 table_n_02_1 - table_n_02)\n    (:init (dusty shelf_n_01_1) (dusty table_n_02_1) (ontop rag_n_01_1 table_n_02_1))\n    (:goal (and (under rag_n_01_1 table_n_02_1) (not (dusty table_n_02_1)) (not (dusty shelf_n_01_1))))\n)\nAction to be finished:\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_under)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "polishing_shoes_0_Wainscott_0_int_0_2021-06-10_21-28-31",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem polishing_shoes)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 - floor_n_01 rag_n_01_1 - rag_n_01 shoe_n_01_1 shoe_n_01_2 - shoe_n_01 sink_n_01_1 - sink_n_01)\n    (:init (not (soaked rag_n_01_1)) (onfloor rag_n_01_1 floor_n_01_1) (onfloor shoe_n_01_1 floor_n_01_1) (onfloor shoe_n_01_2 floor_n_01_1) (stained shoe_n_01_1) (stained shoe_n_01_2))\n    (:goal (and (soaked rag_n_01_1) (nextto rag_n_01_1 sink_n_01_1) (not (stained shoe_n_01_2)) (not (stained shoe_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "polishing_silver_0_Merom_1_int_0_2021-10-26_11-43-15",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem polishing_silver)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 rag_n_01_1 - rag_n_01 spoon_n_01_1 spoon_n_01_2 spoon_n_01_3 spoon_n_01_4 - spoon_n_01)\n    (:init (dusty spoon_n_01_1) (dusty spoon_n_01_3) (dusty spoon_n_01_4) (inside rag_n_01_1 cabinet_n_01_1) (inside spoon_n_01_1 cabinet_n_01_1) (inside spoon_n_01_2 cabinet_n_01_1) (inside spoon_n_01_3 cabinet_n_01_1) (inside spoon_n_01_4 cabinet_n_01_1))\n    (:goal (and (inside spoon_n_01_4 cabinet_n_01_1) (not (dusty spoon_n_01_3)) (inside spoon_n_01_3 cabinet_n_01_1) (not (dusty spoon_n_01_1))))\n)\nAction to be finished:\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "preparing_a_shower_for_child_0_Ihlen_0_int_0_2021-10-25_21-36-25",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem preparing_a_shower_for_child)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 - floor_n_01 shampoo_n_01_1 - shampoo_n_01 sink_n_01_1 - sink_n_01 soap_n_01_1 - soap_n_01 towel_n_01_1 - towel_n_01)\n    (:init (onfloor agent_n_01_1 floor_n_01_1) (onfloor shampoo_n_01_1 floor_n_01_1) (onfloor soap_n_01_1 floor_n_01_1) (onfloor towel_n_01_1 floor_n_01_1))\n    (:goal (and (nextto soap_n_01_1 sink_n_01_1) (onfloor towel_n_01_1 floor_n_01_1) (onfloor shampoo_n_01_1 floor_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "preparing_salad_0_Pomaria_1_int_1_2021-10-26_14-17-24",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem preparing_salad)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent apple_n_01_1 apple_n_01_2 - apple_n_01 cabinet_n_01_1 - cabinet_n_01 carving_knife_n_01_1 - carving_knife_n_01 countertop_n_01_1 - countertop_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 lettuce_n_03_1 lettuce_n_03_2 - lettuce_n_03 plate_n_04_2 - plate_n_04 radish_n_01_1 radish_n_01_2 - radish_n_01 tomato_n_01_2 - tomato_n_01)\n    (:init (inside carving_knife_n_01_1 cabinet_n_01_1) (inside plate_n_04_2 cabinet_n_01_1) (inside tomato_n_01_2 electric_refrigerator_n_01_1) (not (dusty plate_n_04_2)) (ontop apple_n_01_1 countertop_n_01_1) (ontop apple_n_01_2 countertop_n_01_1) (ontop lettuce_n_03_1 countertop_n_01_1) (ontop lettuce_n_03_2 countertop_n_01_1) (ontop radish_n_01_1 countertop_n_01_1) (ontop radish_n_01_2 countertop_n_01_1))\n    (:goal (and (sliced apple_n_01_1) (ontop tomato_n_01_2 plate_n_04_2) (ontop lettuce_n_03_1 plate_n_04_2) (sliced apple_n_01_2)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action slice_carvingknife)\n:parameters (?obj - object ?knife - carving_knife_n_01 ?board - countertop_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "preserving_food_0_Rs_int_0_2021-08-25_15-53-33",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem preserving_food)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent beef_n_02_1 - beef_n_02 carving_knife_n_01_1 - carving_knife_n_01 countertop_n_01_1 - countertop_n_01 jar_n_01_1 - jar_n_01 pan_n_01_1 - pan_n_01 strawberry_n_01_1 strawberry_n_01_2 - strawberry_n_01)\n    (:init (ontop beef_n_02_1 countertop_n_01_1) (ontop carving_knife_n_01_1 countertop_n_01_1) (ontop jar_n_01_1 countertop_n_01_1) (ontop pan_n_01_1 countertop_n_01_1) (ontop strawberry_n_01_1 countertop_n_01_1) (ontop strawberry_n_01_2 countertop_n_01_1) (open jar_n_01_1))\n    (:goal (and (inside strawberry_n_01_2 jar_n_01_1) (inside strawberry_n_01_1 jar_n_01_1) (cooked strawberry_n_01_2) (sliced strawberry_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action cook)\n:parameters (?obj - object ?pan - pan_n_01)\n:precondition ()\n:effect ()\n)\n(:action slice_carvingknife)\n:parameters (?obj - object ?knife - carving_knife_n_01 ?board - countertop_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "putting_away_Christmas_decorations_0_Wainscott_0_int_0_2021-06-06_17-03-25",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem putting_away_Christmas_decorations)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bow_n_08_1 bow_n_08_2 - bow_n_08 cabinet_n_01_1 - cabinet_n_01 floor_n_01_1 - floor_n_01 ribbon_n_01_1 ribbon_n_01_3 - ribbon_n_01)\n    (:init (onfloor bow_n_08_1 floor_n_01_1) (onfloor bow_n_08_2 floor_n_01_1) (onfloor ribbon_n_01_1 floor_n_01_1) (onfloor ribbon_n_01_3 floor_n_01_1))\n    (:goal (and (inside ribbon_n_01_3 cabinet_n_01_1) (nextto bow_n_08_2 cabinet_n_01_1) (nextto bow_n_08_1 cabinet_n_01_1) (inside ribbon_n_01_1 cabinet_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "putting_away_Halloween_decorations_0_Rs_int_0_2021-10-25_22-42-17",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem putting_away_Halloween_decorations)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 caldron_n_01_1 - caldron_n_01 candle_n_01_2 candle_n_01_3 - candle_n_01 floor_n_01_1 - floor_n_01 pumpkin_n_02_1 - pumpkin_n_02 sheet_n_03_1 - sheet_n_03 table_n_02_1 - table_n_02)\n    (:init (onfloor caldron_n_01_1 floor_n_01_1) (onfloor candle_n_01_2 floor_n_01_1) (onfloor candle_n_01_3 floor_n_01_1) (onfloor pumpkin_n_02_1 floor_n_01_1) (ontop sheet_n_03_1 table_n_02_1))\n    (:goal (and (inside candle_n_01_2 cabinet_n_01_1) (inside pumpkin_n_02_1 cabinet_n_01_1) (nextto caldron_n_01_1 table_n_02_1) (inside candle_n_01_3 cabinet_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "putting_away_toys_0_Ihlen_0_int_0_2021-10-25_22-47-44",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem putting_away_toys)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent carton_n_02_1 - carton_n_02 floor_n_01_1 floor_n_01_2 - floor_n_01 plaything_n_01_2 plaything_n_01_3 plaything_n_01_5 plaything_n_01_6 - plaything_n_01)\n    (:init (onfloor carton_n_02_1 floor_n_01_1) (onfloor plaything_n_01_2 floor_n_01_1) (onfloor plaything_n_01_3 floor_n_01_1) (onfloor plaything_n_01_5 floor_n_01_2) (onfloor plaything_n_01_6 floor_n_01_2))\n    (:goal (and (inside plaything_n_01_5 carton_n_02_1) (inside plaything_n_01_3 carton_n_02_1) (inside plaything_n_01_6 carton_n_02_1) (inside plaything_n_01_2 carton_n_02_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "putting_dishes_away_after_cleaning_0_Ihlen_1_int_0_2021-10-25_22-54-09",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem putting_dishes_away_after_cleaning)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 countertop_n_01_1 countertop_n_01_2 - countertop_n_01 plate_n_04_1 plate_n_04_6 plate_n_04_7 plate_n_04_8 - plate_n_04)\n    (:init (ontop plate_n_04_1 countertop_n_01_1) (ontop plate_n_04_6 countertop_n_01_2) (ontop plate_n_04_7 countertop_n_01_2) (ontop plate_n_04_8 countertop_n_01_2))\n    (:goal (and (inside plate_n_04_7 cabinet_n_01_1) (inside plate_n_04_8 cabinet_n_01_1) (inside plate_n_04_6 cabinet_n_01_1) (inside plate_n_04_1 cabinet_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "putting_leftovers_away_0_Ihlen_1_int_0_2021-06-08_13-42-57",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem putting_leftovers_away)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent countertop_n_01_1 - countertop_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 pasta_n_02_2 - pasta_n_02 sauce_n_01_2 sauce_n_01_3 sauce_n_01_4 - sauce_n_01)\n    (:init (ontop pasta_n_02_2 countertop_n_01_1) (ontop sauce_n_01_2 countertop_n_01_1) (ontop sauce_n_01_3 countertop_n_01_1) (ontop sauce_n_01_4 countertop_n_01_1))\n    (:goal (and (inside pasta_n_02_2 electric_refrigerator_n_01_1) (inside sauce_n_01_4 electric_refrigerator_n_01_1) (inside sauce_n_01_2 electric_refrigerator_n_01_1) (inside sauce_n_01_3 electric_refrigerator_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "putting_up_Christmas_decorations_inside_0_Ihlen_1_int_0_2021-06-03_14-27-09",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem putting_up_Christmas_decorations_inside)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bow_n_08_1 bow_n_08_3 - bow_n_08 candle_n_01_1 - candle_n_01 carton_n_02_1 - carton_n_02 christmas_tree_n_05_1 - christmas_tree_n_05 floor_n_01_1 - floor_n_01 sofa_n_01_1 - sofa_n_01 table_n_02_1 - table_n_02 wrapping_n_01_1 - wrapping_n_01)\n    (:init (inside bow_n_08_1 carton_n_02_1) (inside bow_n_08_3 carton_n_02_1) (inside candle_n_01_1 carton_n_02_1) (onfloor christmas_tree_n_05_1 floor_n_01_1) (onfloor wrapping_n_01_1 floor_n_01_1))\n    (:goal (and (ontop bow_n_08_1 sofa_n_01_1) (nextto wrapping_n_01_1 christmas_tree_n_05_1) (ontop bow_n_08_3 sofa_n_01_1) (ontop candle_n_01_1 table_n_02_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "re-shelving_library_books_0_Rs_int_0_2021-10-25_21-22-26",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem re-shelving_library_books)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent book_n_02_1 book_n_02_2 book_n_02_3 book_n_02_4 book_n_02_5 book_n_02_6 book_n_02_7 book_n_02_8 - book_n_02 shelf_n_01_1 - shelf_n_01 table_n_02_1 - table_n_02)\n    (:init (ontop book_n_02_1 table_n_02_1) (ontop book_n_02_2 table_n_02_1) (ontop book_n_02_3 table_n_02_1) (ontop book_n_02_4 table_n_02_1) (ontop book_n_02_5 table_n_02_1) (ontop book_n_02_6 table_n_02_1) (ontop book_n_02_7 table_n_02_1) (ontop book_n_02_8 table_n_02_1))\n    (:goal (and (ontop book_n_02_8 table_n_02_1) (ontop book_n_02_4 shelf_n_01_1) (ontop book_n_02_5 table_n_02_1) (ontop book_n_02_2 shelf_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "rearranging_furniture_0_Pomaria_2_int_1_2021-06-22_16-39-21",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem rearranging_furniture)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bed_n_01_1 - bed_n_01 door_n_01_1 - door_n_01 floor_n_01_1 - floor_n_01 lamp_n_02_1 lamp_n_02_2 - lamp_n_02 seat_n_03_2 - seat_n_03 window_n_01_1 - window_n_01)\n    (:init (onfloor lamp_n_02_1 floor_n_01_1) (onfloor lamp_n_02_2 floor_n_01_1) (ontop seat_n_03_2 bed_n_01_1))\n    (:goal (and (nextto lamp_n_02_1 door_n_01_1) (nextto lamp_n_02_2 window_n_01_1) (nextto seat_n_03_2 window_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "serving_a_meal_0_Merom_1_int_0_2021-10-26_00-34-17",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem serving_a_meal)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 cake_n_03_2 - cake_n_03 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 fork_n_01_2 - fork_n_01 plate_n_04_2 - plate_n_04 salad_n_01_2 - salad_n_01 soup_n_01_1 soup_n_01_2 - soup_n_01 spoon_n_01_2 - spoon_n_01 table_n_02_1 - table_n_02)\n    (:init (inside cake_n_03_2 electric_refrigerator_n_01_1) (inside fork_n_01_2 cabinet_n_01_1) (inside plate_n_04_2 cabinet_n_01_1) (inside salad_n_01_2 electric_refrigerator_n_01_1) (inside spoon_n_01_2 cabinet_n_01_1) (ontop soup_n_01_1 table_n_02_1) (ontop soup_n_01_2 table_n_02_1))\n    (:goal (and (ontop fork_n_01_2 table_n_02_1) (nextto salad_n_01_2 plate_n_04_2) (nextto spoon_n_01_2 soup_n_01_1) (nextto cake_n_03_2 plate_n_04_2)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "serving_hors_d_oeuvres_0_Wainscott_0_int_0_2021-10-26_14-00-22",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem serving_hors_d_oeuvres)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cheese_n_01_2 - cheese_n_01 cracker_n_01_1 cracker_n_01_2 cracker_n_01_3 cracker_n_01_4 - cracker_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 floor_n_01_1 - floor_n_01 parsley_n_02_3 - parsley_n_02 salad_n_01_3 - salad_n_01 table_n_02_1 - table_n_02 tray_n_01_1 - tray_n_01)\n    (:init (inside cheese_n_01_2 electric_refrigerator_n_01_1) (inside parsley_n_02_3 electric_refrigerator_n_01_1) (inside salad_n_01_3 electric_refrigerator_n_01_1) (onfloor tray_n_01_1 floor_n_01_1) (ontop cracker_n_01_1 table_n_02_1) (ontop cracker_n_01_2 table_n_02_1) (ontop cracker_n_01_3 table_n_02_1) (ontop cracker_n_01_4 table_n_02_1))\n    (:goal (and (ontop cracker_n_01_1 table_n_02_1) (ontop parsley_n_02_3 cheese_n_01_2) (ontop tray_n_01_1 table_n_02_1) (nextto salad_n_01_3 cracker_n_01_4)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "setting_mousetraps_0_Beechwood_1_int_0_2021-10-26_13-53-26",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem setting_mousetraps)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bed_n_01_1 - bed_n_01 floor_n_01_1 - floor_n_01 mousetrap_n_01_1 mousetrap_n_01_2 mousetrap_n_01_3 mousetrap_n_01_4 - mousetrap_n_01 toilet_n_02_1 - toilet_n_02)\n    (:init (ontop mousetrap_n_01_1 bed_n_01_1) (ontop mousetrap_n_01_2 bed_n_01_1) (ontop mousetrap_n_01_3 bed_n_01_1) (ontop mousetrap_n_01_4 bed_n_01_1))\n    (:goal (and (onfloor mousetrap_n_01_2 floor_n_01_1) (onfloor mousetrap_n_01_1 floor_n_01_1) (nextto mousetrap_n_01_4 toilet_n_02_1) (nextto mousetrap_n_01_3 toilet_n_02_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_onfloor)\n:parameters (?obj_in_hand - object ?floor - floor_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "setting_up_candles_0_Wainscott_0_int_0_2021-10-26_13-40-51",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem setting_up_candles)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent candle_n_01_1 candle_n_01_3 candle_n_01_5 candle_n_01_6 - candle_n_01 carton_n_02_1 carton_n_02_2 - carton_n_02 table_n_02_1 table_n_02_2 - table_n_02)\n    (:init (inside candle_n_01_1 carton_n_02_1) (inside candle_n_01_3 carton_n_02_1) (inside candle_n_01_5 carton_n_02_2) (inside candle_n_01_6 carton_n_02_2))\n    (:goal (and (ontop candle_n_01_3 table_n_02_1) (ontop candle_n_01_1 table_n_02_1) (ontop candle_n_01_5 table_n_02_2) (ontop candle_n_01_6 table_n_02_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "sorting_books_0_Pomaria_1_int_0_2021-10-26_13-27-18",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem sorting_books)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent book_n_02_1 book_n_02_2 - book_n_02 floor_n_01_1 - floor_n_01 hardback_n_01_1 hardback_n_01_2 - hardback_n_01 shelf_n_01_1 - shelf_n_01 table_n_02_1 - table_n_02)\n    (:init (onfloor book_n_02_1 floor_n_01_1) (onfloor hardback_n_01_2 floor_n_01_1) (ontop book_n_02_2 table_n_02_1) (ontop hardback_n_01_1 table_n_02_1))\n    (:goal (and (ontop hardback_n_01_1 shelf_n_01_1) (ontop book_n_02_2 shelf_n_01_1) (ontop hardback_n_01_2 shelf_n_01_1) (ontop book_n_02_1 shelf_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "sorting_groceries_0_Wainscott_0_int_0_2021-10-26_13-36-01",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem sorting_groceries)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent apple_n_01_2 - apple_n_01 cheese_n_01_1 - cheese_n_01 countertop_n_01_1 - countertop_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 meat_n_01_1 - meat_n_01 orange_n_01_1 orange_n_01_3 - orange_n_01 table_n_02_1 - table_n_02)\n    (:init (ontop apple_n_01_2 countertop_n_01_1) (ontop cheese_n_01_1 table_n_02_1) (ontop meat_n_01_1 table_n_02_1) (ontop orange_n_01_1 table_n_02_1) (ontop orange_n_01_3 table_n_02_1))\n    (:goal (and (nextto apple_n_01_2 apple_n_01_2) (inside cheese_n_01_1 electric_refrigerator_n_01_1) (inside meat_n_01_1 electric_refrigerator_n_01_1) (nextto orange_n_01_1 orange_n_01_3)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "sorting_mail_0_Wainscott_0_int_1_2021-10-26_14-38-16",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem sorting_mail)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent envelope_n_01_1 envelope_n_01_2 envelope_n_01_3 envelope_n_01_4 - envelope_n_01 floor_n_01_1 - floor_n_01 newspaper_n_03_1 newspaper_n_03_2 - newspaper_n_03)\n    (:init (onfloor envelope_n_01_1 floor_n_01_1) (onfloor envelope_n_01_2 floor_n_01_1) (onfloor envelope_n_01_3 floor_n_01_1) (onfloor envelope_n_01_4 floor_n_01_1) (onfloor newspaper_n_03_1 floor_n_01_1) (onfloor newspaper_n_03_2 floor_n_01_1))\n    (:goal (and (ontop envelope_n_01_3 envelope_n_01_2) (ontop newspaper_n_03_1 newspaper_n_03_1) (ontop envelope_n_01_4 envelope_n_01_1) (ontop newspaper_n_03_2 newspaper_n_03_2)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "storing_food_0_Rs_int_0_2021-10-25_21-27-36",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem storing_food)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 chip_n_04_2 - chip_n_04 countertop_n_01_1 - countertop_n_01 sugar_n_01_1 sugar_n_01_2 - sugar_n_01 vegetable_oil_n_01_2 - vegetable_oil_n_01)\n    (:init (ontop chip_n_04_2 countertop_n_01_1) (ontop sugar_n_01_1 countertop_n_01_1) (ontop sugar_n_01_2 countertop_n_01_1) (ontop vegetable_oil_n_01_2 countertop_n_01_1))\n    (:goal (and (inside vegetable_oil_n_01_2 cabinet_n_01_1) (inside sugar_n_01_1 cabinet_n_01_1) (inside chip_n_04_2 cabinet_n_01_1) (inside sugar_n_01_2 cabinet_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "storing_the_groceries_0_Beechwood_0_int_0_2021-10-26_13-13-47",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem storing_the_groceries)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent broccoli_n_02_1 broccoli_n_02_2 - broccoli_n_02 cabinet_n_01_1 - cabinet_n_01 cereal_n_03_1 - cereal_n_03 countertop_n_01_1 - countertop_n_01 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 lettuce_n_03_1 - lettuce_n_03 raspberry_n_02_1 - raspberry_n_02)\n    (:init (ontop broccoli_n_02_1 countertop_n_01_1) (ontop broccoli_n_02_2 countertop_n_01_1) (ontop cereal_n_03_1 countertop_n_01_1) (ontop lettuce_n_03_1 countertop_n_01_1) (ontop raspberry_n_02_1 countertop_n_01_1))\n    (:goal (and (nextto broccoli_n_02_1 broccoli_n_02_2) (inside raspberry_n_02_1 electric_refrigerator_n_01_1) (inside lettuce_n_03_1 electric_refrigerator_n_01_1) (inside cereal_n_03_1 cabinet_n_01_1)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "thawing_frozen_food_0_Pomaria_1_int_0_2021-10-26_13-10-33",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem thawing_frozen_food)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent date_n_08_1 - date_n_08 electric_refrigerator_n_01_1 - electric_refrigerator_n_01 fish_n_02_1 fish_n_02_2 fish_n_02_4 - fish_n_02 olive_n_04_1 - olive_n_04 sink_n_01_1 - sink_n_01)\n    (:init (frozen date_n_08_1) (frozen fish_n_02_1) (frozen fish_n_02_2) (frozen fish_n_02_4) (frozen olive_n_04_1) (inside date_n_08_1 electric_refrigerator_n_01_1) (inside fish_n_02_1 electric_refrigerator_n_01_1) (inside fish_n_02_2 electric_refrigerator_n_01_1) (inside fish_n_02_4 electric_refrigerator_n_01_1) (inside olive_n_04_1 electric_refrigerator_n_01_1))\n    (:goal (and (nextto olive_n_04_1 sink_n_01_1) (nextto fish_n_02_2 sink_n_01_1) (nextto fish_n_02_4 sink_n_01_1) (nextto date_n_08_1 fish_n_02_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "throwing_away_leftovers_0_Ihlen_1_int_0_2021-06-04_19-52-40",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem throwing_away_leftovers)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent ashcan_n_01_1 - ashcan_n_01 floor_n_01_1 - floor_n_01 hamburger_n_01_1 hamburger_n_01_2 hamburger_n_01_3 - hamburger_n_01 plate_n_04_1 plate_n_04_2 plate_n_04_3 - plate_n_04)\n    (:init (onfloor ashcan_n_01_1 floor_n_01_1) (ontop hamburger_n_01_1 plate_n_04_1) (ontop hamburger_n_01_2 plate_n_04_3) (ontop hamburger_n_01_3 plate_n_04_2))\n    (:goal (and (inside hamburger_n_01_2 ashcan_n_01_1) (inside hamburger_n_01_1 ashcan_n_01_1) (inside hamburger_n_01_3 ashcan_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "unpacking_suitcase_0_Benevolence_1_int_0_2021-06-08_17-58-34",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem unpacking_suitcase)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent carton_n_02_1 - carton_n_02 floor_n_01_1 - floor_n_01 notebook_n_01_1 - notebook_n_01 perfume_n_02_1 - perfume_n_02 sock_n_01_1 sock_n_01_2 - sock_n_01 sofa_n_01_1 - sofa_n_01 toothbrush_n_01_1 - toothbrush_n_01)\n    (:init (inside notebook_n_01_1 carton_n_02_1) (inside perfume_n_02_1 carton_n_02_1) (inside sock_n_01_1 carton_n_02_1) (inside sock_n_01_2 carton_n_02_1) (inside toothbrush_n_01_1 carton_n_02_1) (onfloor agent_n_01_1 floor_n_01_1) (onfloor carton_n_02_1 floor_n_01_1))\n    (:goal (and (ontop notebook_n_01_1 sofa_n_01_1) (ontop perfume_n_02_1 sofa_n_01_1) (onfloor carton_n_02_1 floor_n_01_1) (ontop toothbrush_n_01_1 sofa_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_nextto_ontop)\n:parameters (?obj_in_hand - object ?obj1 - object ?obj2 - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "vacuuming_floors_0_Ihlen_1_int_0_2021-06-08_18-03-55",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem vacuuming_floors)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent ashcan_n_01_1 - ashcan_n_01 floor_n_01_1 - floor_n_01 vacuum_n_04_1 - vacuum_n_04)\n    (:init (dusty floor_n_01_1) (onfloor agent_n_01_1 floor_n_01_1) (onfloor ashcan_n_01_1 floor_n_01_1) (onfloor vacuum_n_04_1 floor_n_01_1))\n    (:goal (not (dusty floor_n_01_1)))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_vacuum)\n:parameters (?vacuum - vacuum_n_04 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "washing_cars_or_other_vehicles_0_Ihlen_0_int_0_2021-10-25_22-38-10",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem washing_cars_or_other_vehicles)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bucket_n_01_1 - bucket_n_01 car_n_01_1 - car_n_01 floor_n_01_1 - floor_n_01 rag_n_01_1 - rag_n_01 sink_n_01_1 - sink_n_01 soap_n_01_1 - soap_n_01)\n    (:init (dusty car_n_01_1) (onfloor car_n_01_1 floor_n_01_1) (ontop bucket_n_01_1 car_n_01_1) (ontop rag_n_01_1 car_n_01_1) (ontop soap_n_01_1 car_n_01_1) (stained car_n_01_1))\n    (:goal (and (not (dusty car_n_01_1)) (not (stained car_n_01_1))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "washing_dishes_0_Benevolence_1_int_0_2021-06-08_18-07-48",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem washing_dishes)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bowl_n_01_1 - bowl_n_01 countertop_n_01_1 - countertop_n_01 cup_n_01_1 - cup_n_01 plate_n_04_1 plate_n_04_2 - plate_n_04 scrub_brush_n_01_1 - scrub_brush_n_01 sink_n_01_1 - sink_n_01)\n    (:init (inside scrub_brush_n_01_1 sink_n_01_1) (ontop bowl_n_01_1 countertop_n_01_1) (ontop cup_n_01_1 countertop_n_01_1) (ontop plate_n_04_1 countertop_n_01_1) (ontop plate_n_04_2 countertop_n_01_1) (stained bowl_n_01_1) (stained cup_n_01_1) (stained plate_n_04_1) (stained plate_n_04_2))\n    (:goal (and (not (stained plate_n_04_1)) (not (stained plate_n_04_2)) (not (stained cup_n_01_1)) (not (stained bowl_n_01_1))))\n)\nAction to be finished:\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "washing_floor_0_Ihlen_1_int_1_2021-10-26_14-53-28",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem washing_floor)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent bucket_n_01_1 - bucket_n_01 floor_n_01_1 - floor_n_01 sink_n_01_1 - sink_n_01 soap_n_01_1 - soap_n_01 towel_n_01_1 - towel_n_01)\n    (:init (dusty floor_n_01_1) (not (stained towel_n_01_1)) (onfloor agent_n_01_1 floor_n_01_1) (onfloor bucket_n_01_1 floor_n_01_1) (onfloor soap_n_01_1 floor_n_01_1) (onfloor towel_n_01_1 floor_n_01_1) (ontop soap_n_01_1 towel_n_01_1) (stained floor_n_01_1))\n    (:goal (and (not (stained floor_n_01_1)) (not (dusty floor_n_01_1))))\n)\nAction to be finished:\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_towel)\n:parameters (?hand_towel - towel_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_dusty_towel)\n:parameters (?towel - towel_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "washing_pots_and_pans_0_Pomaria_1_int_0_2021-10-26_13-06-44",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem washing_pots_and_pans)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent cabinet_n_01_1 - cabinet_n_01 countertop_n_01_1 countertop_n_01_2 - countertop_n_01 pan_n_01_1 pan_n_01_3 - pan_n_01 scrub_brush_n_01_1 - scrub_brush_n_01 sink_n_01_1 - sink_n_01 soap_n_01_1 - soap_n_01 teapot_n_01_1 - teapot_n_01)\n    (:init (inside soap_n_01_1 sink_n_01_1) (ontop pan_n_01_1 countertop_n_01_1) (ontop pan_n_01_3 countertop_n_01_2) (ontop scrub_brush_n_01_1 countertop_n_01_2) (ontop teapot_n_01_1 countertop_n_01_1) (soaked scrub_brush_n_01_1) (stained pan_n_01_1) (stained pan_n_01_3) (stained teapot_n_01_1))\n    (:goal (and (not (stained teapot_n_01_1)) (inside teapot_n_01_1 cabinet_n_01_1) (not (stained pan_n_01_1)) (not (stained pan_n_01_3))))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action clean_stained_brush)\n:parameters (?scrub_brush - scrub_brush_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action place_inside)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "watering_houseplants_0_Beechwood_0_int_0_2021-10-26_15-20-01",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem watering_houseplants)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 floor_n_01_2 - floor_n_01 pot_plant_n_01_1 pot_plant_n_01_2 pot_plant_n_01_3 - pot_plant_n_01 sink_n_01_1 - sink_n_01)\n    (:init (not (soaked pot_plant_n_01_1)) (not (soaked pot_plant_n_01_2)) (not (soaked pot_plant_n_01_3)) (onfloor pot_plant_n_01_1 floor_n_01_1) (onfloor pot_plant_n_01_2 floor_n_01_1) (onfloor pot_plant_n_01_3 floor_n_01_2))\n    (:goal (and (soaked pot_plant_n_01_3) (soaked pot_plant_n_01_1) (soaked pot_plant_n_01_2)))\n)\nAction to be finished:\n(:action place_nextto)\n:parameters (?obj_in_hand - object ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action toggle_on)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action soak)\n:parameters (?obj1 - object ?sink - sink_n_01 ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    },
    {
        "identifier": "waxing_cars_or_other_vehicles_0_Ihlen_0_int_0_2021-10-25_23-03-46",
        "llm_prompt": "\nThe following is predicates defined in this domain file. Pay attention to the types for each predicate.\n(define (domain igibson)\n\n    (:requirements :strips :adl :typing :negative-preconditions)\n\n    (:types \n        vacuum_n_04 facsimile_n_02 dishtowel_n_01 apparel_n_01 seat_n_03 bottle_n_01 mouse_n_04 window_n_01 scanner_n_02 \n        sauce_n_01 spoon_n_01 date_n_08 egg_n_02 cabinet_n_01 yogurt_n_01 parsley_n_02 notebook_n_01 dryer_n_01 saucepan_n_01 \n        soap_n_01 package_n_02 headset_n_01 fish_n_02 vehicle_n_01 chestnut_n_03 grape_n_01 wrapping_n_01 makeup_n_01 mug_n_04 \n        pasta_n_02 beef_n_02 scrub_brush_n_01 cracker_n_01 flour_n_01 sunglass_n_01 cookie_n_01 bed_n_01 lamp_n_02 food_n_02 \n        painting_n_01 carving_knife_n_01 pop_n_02 tea_bag_n_01 sheet_n_03 tomato_n_01 agent_n_01 hat_n_01 dish_n_01 cheese_n_01 \n        perfume_n_02 toilet_n_02 broccoli_n_02 book_n_02 towel_n_01 table_n_02 pencil_n_01 rag_n_01 peach_n_03 water_n_06 cup_n_01 \n        radish_n_01 marker_n_03 tile_n_01 box_n_01 screwdriver_n_01 raspberry_n_02 banana_n_02 grill_n_02 caldron_n_01 vegetable_oil_n_01 \n        necklace_n_01 brush_n_02 washer_n_03 hamburger_n_01 catsup_n_01 sandwich_n_01 plaything_n_01 candy_n_01 cereal_n_03 door_n_01 \n        food_n_01 newspaper_n_03 hanger_n_02 carrot_n_03 salad_n_01 toothpaste_n_01 blender_n_01 sofa_n_01 plywood_n_01 olive_n_04 briefcase_n_01 \n        christmas_tree_n_05 bowl_n_01 casserole_n_02 apple_n_01 basket_n_01 pot_plant_n_01 backpack_n_01 sushi_n_01 saw_n_02 toothbrush_n_01 \n        lemon_n_01 pad_n_01 receptacle_n_01 sink_n_01 countertop_n_01 melon_n_01 bracelet_n_02 modem_n_01 pan_n_01 oatmeal_n_01 calculator_n_02 \n        duffel_bag_n_01 sandal_n_01 floor_n_01 snack_food_n_01 stocking_n_01 dishwasher_n_01 pencil_box_n_01 chicken_n_01 jar_n_01 alarm_n_02 \n        stove_n_01 plate_n_04 highlighter_n_02 umbrella_n_01 piece_of_cloth_n_01 bin_n_01 ribbon_n_01 chip_n_04 shelf_n_01 bucket_n_01 shampoo_n_01 \n        folder_n_02 shoe_n_01 detergent_n_02 milk_n_01 beer_n_01 shirt_n_01 dustpan_n_02 cube_n_05 broom_n_01 candle_n_01 pen_n_01 microwave_n_02 \n        knife_n_01 wreath_n_01 car_n_01 soup_n_01 sweater_n_01 tray_n_01 juice_n_01 underwear_n_01 orange_n_01 envelope_n_01 fork_n_01 lettuce_n_03 \n        bathtub_n_01 earphone_n_01 pool_n_01 printer_n_03 sack_n_01 highchair_n_01 cleansing_agent_n_01 kettle_n_01 vidalia_onion_n_01 mousetrap_n_01 \n        bread_n_01 meat_n_01 mushroom_n_05 cake_n_03 vessel_n_03 bow_n_08 gym_shoe_n_01 hammer_n_02 teapot_n_01 chair_n_01 jewelry_n_01 pumpkin_n_02 sugar_n_01 \n        shower_n_01 ashcan_n_01 hand_towel_n_01 pork_n_01 strawberry_n_01 electric_refrigerator_n_01 oven_n_01 ball_n_01 document_n_01 sock_n_01 beverage_n_01 \n        hardback_n_01 scraper_n_01 carton_n_02\n        agent\n    )\n\n    (:predicates \n        (inside ?obj1 - object ?obj2 - object)\n        (nextto ?obj1 - object ?obj2 - object)\n        (ontop ?obj1 - object ?obj2 - object)\n        (under ?obj1 - object ?obj2 - object)\n        (cooked ?obj1 - object)\n        (dusty ?obj1 - object)\n        (frozen ?obj1 - object)\n        (open ?obj1 - object)\n        (stained ?obj1 - object)\n        (sliced ?obj1 - object)\n        (soaked ?obj1 - object)\n        (toggled_on ?obj1 - object)\n        (onfloor ?obj1 - object ?floor1 - object)\n        (holding ?obj1 - object)\n        (handsfull ?agent1 - agent)\n        (in_reach_of_agent ?obj1 - object)\n        (same_obj ?obj1 - object ?obj2 - object)\n    )\n    ;; Actions to be predicted\n)\nObjective: Given the problem file of pddl, which defines objects in the task (:objects), initial conditions (:init) and goal conditions (:goal), write the body of PDDL actions (:precondition and :effect) given specific action names and parameters. \nEach PDDL action definition consists of four main components: action name, parameters, precondition, and effect. Here is the general format to follow:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nThe :parameters is the list of variables on which the action operates. It lists variable names and variable types. \nThe :precondition is a first-order logic sentence specifying preconditions for an action. The precondition consists of predicates and 3 possible logical operators: or, and, and not. The precondition should be structured in Disjunctive Normal Form (DNF), meaning an OR of ANDs. The not operator should only be used within these conjunctions. For example, (or (and (predicate1 ?x) (predicate2 ?y)) (and (predicate3 ?x)))\nThe :effect lists the changes which the action imposes on the current state. The precondition consists of predicates and 3 possible logical operators: and, not and when. 1. The effects should generally be several effects connected by AND operators. 2. For each effect, if it is a conditional effect, use WHEN to check the conditions. The semantics of (when [condition] [effect]) are as follows: If [condition] is true before the action, then [effect] occurs afterwards. 3. If it is not a conditional effect, use predicates directly. 4. The NOT operator is used to negate a predicate, signifying that the condition will not hold after the action is executed. And example of effect is (and (when (predicate1 ?x) (not (predicate2 ?y))) (predicate3 ?x))\nIn any case, the occurrence of a predicate should agree with its declaration in terms of number and types of arguments defined in DOMAIN FILE at the beginning.\nHere are some other commonly used actions and their PDDL definition:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action grasp\n:parameters (?obj - object ?agent - agent)\n:precondition (and (not (holding ?obj))\n                    (not (handsfull ?agent)) \n                    (in_reach_of_agent ?obj)\n                    (not (exists (?obj2 - object) (and (inside ?obj ?obj2) (not (open ?obj2)))))\n                )\n:effect (and (holding ?obj) \n                (handsfull ?agent)\n                ;; Conditional effects for all predicates involving ?obj and ?other_obj\n                (forall (?other_obj - object)\n                    (and (not (inside ?obj ?other_obj))\n                            (not (ontop ?obj ?other_obj))\n                            (not (under ?obj ?other_obj))\n                            (not (under ?other_obj ?obj))\n                            (not (nextto ?obj ?other_obj))\n                            (not (nextto ?other_obj ?obj))\n                            (not (onfloor ?obj ?other_obj))\n                            ;; Add other predicates as needed\n                    )\n                )\n            )\n)\n\nhint: \n1. In many cases WHEN is not necessary. Don't enforce the use of WHEN\n2. You MUST only use predicates and object types exactly as they appear in the domain file at the beginning. Now given the input, please fill in the action body for each provided actions in PDDL format. \nFor actions to be finished, write their preconditions and effects, and return in standard PDDL format:\n(:action [action name]\n  :parameters ([action parameters])\n  :precondition ([action precondition])\n  :effect ([action effect]) \n)\nConcatenate all actions PDDL string into a single string. Output in json format where key is \"output\" and value is your output string: {\"output\": YOUR OUTPUT STRING}\n\nHere is an example of the input problem file and unfinished action:\nInput:\nProblem file:\n(define (problem cleaning_floor_0)\n    (:domain igibson)\n\n    (:objects\n    \tfloor_n_01_1 - floor_n_01\n    \trag_n_01_1 - rag_n_01\n    \tsink_n_01_1 - sink_n_01\n    \tagent_n_01_1 - agent_n_01\n    )\n    \n    (:init \n        (dusty floor_n_01_1) \n        (stained floor_n_01_2) \n        (ontop rag_n_01_1 table_n_02_1) \n        (inroom sink_n_01_1 storage_room) \n        (onfloor agent_n_01_1 floor_n_01_2)\n    )\n    \n    (:goal \n        (and \n        (not (dusty floor_n_01_1)) \n        (not (stained floor_n_01_2))\n        )\n    )\n)\nAction to be finished:\n(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition ()\n        :effect ()\n    )\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition ()\n  :effect ()\n)\nOutput:\n{\"output\":\"(:action navigate_to\n        :parameters (?objto - object ?agent - agent)\n        :precondition (not (in_reach_of_agent ?objto))\n        :effect (and (in_reach_of_agent ?objto) \n                    (forall \n                        (?objfrom - object) \n                        (when \n                            (and \n                                (in_reach_of_agent ?objfrom) \n                                (not (same_obj ?objfrom ?objto))\n                            )\n                            (not (in_reach_of_agent ?objfrom))\n                        )\n                    )\n                )\n)\n(:action clean-stained-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj)\n                      (soaked ?rag)\n                      (holding ?rag))\n  :effect (not (stained ?floor)) \n)\n(:action clean-dusty-floor-rag\n  :parameters (?rag - rag_n_01 ?floor - floor_n_01 ?agent - agent_n_01)\n  :precondition (and (in_reach_of_agent ?floor)\n                      (stained ?obj) \n                      (holding ?rag)) \n  :effect (not (dusty ?floor))\n)\n(:action soak-rag\n  :parameters (?rag - rag_n_01 ?sink - sink_n_01 ?agent - agent_n_01)\n  :precondition  (and (holding ?rag)\n                      (in_reach_of_agent ?sink)\n                      (toggled_on ?sink))\n  :effect (soaked ?rag)\n)\"}\n\nInput:\nProblem file:\n(define (problem waxing_cars_or_other_vehicles)\n    (:domain igibson)\n    (:objects agent_n_01_1 - agent floor_n_01_1 - floor_n_01 rag_n_01_1 - rag_n_01 shelf_n_01_1 - shelf_n_01 vehicle_n_01_1 - vehicle_n_01)\n    (:init (dusty vehicle_n_01_1) (inside rag_n_01_1 shelf_n_01_1) (onfloor vehicle_n_01_1 floor_n_01_1))\n    (:goal (not (dusty vehicle_n_01_1)))\n)\nAction to be finished:\n(:action clean_dusty_rag)\n:parameters (?rag - rag_n_01 ?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action navigate_to)\n:parameters (?objto - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action open)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n(:action grasp)\n:parameters (?obj - object ?agent - agent)\n:precondition ()\n:effect ()\n)\n\nOutput:\n"
    }
]