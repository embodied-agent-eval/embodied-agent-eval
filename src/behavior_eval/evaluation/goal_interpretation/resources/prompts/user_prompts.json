[
    {
        "identifier": "assembling_gift_baskets_0_Beechwood_0_int_0_2021-10-26_12-46-37",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbasket.n.01_1: ['Stained', 'Dusty']\nbasket.n.01_2: ['Stained', 'Dusty']\nbasket.n.01_3: ['Stained', 'Dusty']\nbasket.n.01_4: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ncandle.n.01_1: ['Dusty']\ncandle.n.01_2: ['Dusty']\ncandle.n.01_3: ['Dusty']\ncandle.n.01_4: ['Dusty']\ncookie.n.01_1: ['Frozen', 'Cooked', 'Burnt']\ncookie.n.01_2: ['Frozen', 'Cooked', 'Burnt']\ncookie.n.01_3: ['Frozen', 'Cooked', 'Burnt']\ncookie.n.01_4: ['Frozen', 'Cooked', 'Burnt']\ncheese.n.01_1: ['Frozen', 'Cooked', 'Burnt']\ncheese.n.01_2: ['Frozen', 'Cooked', 'Burnt']\ncheese.n.01_3: ['Frozen', 'Cooked', 'Burnt']\ncheese.n.01_4: ['Frozen', 'Cooked', 'Burnt']\nbow.n.08_1: ['Dusty']\nbow.n.08_2: ['Dusty']\nbow.n.08_3: ['Dusty']\nbow.n.08_4: ['Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\ntable.n.02_2: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'basket.n.01_1', 'floor.n.01_1']\n['onfloor', 'basket.n.01_2', 'floor.n.01_1']\n['onfloor', 'basket.n.01_3', 'floor.n.01_1']\n['onfloor', 'basket.n.01_4', 'floor.n.01_1']\n['ontop', 'candle.n.01_1', 'table.n.02_1']\n['ontop', 'candle.n.01_2', 'table.n.02_1']\n['ontop', 'candle.n.01_3', 'table.n.02_1']\n['ontop', 'candle.n.01_4', 'table.n.02_1']\n['ontop', 'cookie.n.01_1', 'table.n.02_1']\n['ontop', 'cookie.n.01_2', 'table.n.02_1']\n['ontop', 'cookie.n.01_3', 'table.n.02_1']\n['ontop', 'cookie.n.01_4', 'table.n.02_1']\n['ontop', 'cheese.n.01_1', 'table.n.02_2']\n['ontop', 'cheese.n.01_2', 'table.n.02_2']\n['ontop', 'cheese.n.01_3', 'table.n.02_2']\n['ontop', 'cheese.n.01_4', 'table.n.02_2']\n['ontop', 'bow.n.08_1', 'table.n.02_2']\n['ontop', 'bow.n.08_2', 'table.n.02_2']\n['ontop', 'bow.n.08_3', 'table.n.02_2']\n['ontop', 'bow.n.08_4', 'table.n.02_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"assembling_gift_baskets\",\n    \"Goal Instructions\": \"Put one candle, one cheese, one cookie, and one bow into each basket.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "bottling_fruit_0_Wainscott_0_int_0_2021-05-24_19-46-46",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nstrawberry.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\npeach.n.03_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\ncountertop.n.01_1: ['Stained', 'Dusty']\njar.n.01_1: ['Stained', 'Open', 'Dusty']\njar.n.01_2: ['Stained', 'Open', 'Dusty']\ncarving_knife.n.01_1: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['inside', 'strawberry.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'peach.n.03_1', 'electric_refrigerator.n.01_1']\n['not', 'sliced', 'strawberry.n.01_1']\n['not', 'sliced', 'peach.n.03_1']\n['ontop', 'jar.n.01_1', 'countertop.n.01_1']\n['ontop', 'jar.n.01_2', 'countertop.n.01_1']\n['ontop', 'carving_knife.n.01_1', 'countertop.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"bottling_fruit\",\n    \"Goal Instructions\": \"Slice the strawberry and the peach, put the sliced strawberry and peach in separate jars, and close the jars.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "boxing_books_up_for_storage_0_Benevolence_1_int_0_2021-09-10_15-35-47",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbook.n.02_1: ['Dusty']\nbook.n.02_2: ['Dusty']\nbook.n.02_3: ['Dusty']\nbook.n.02_4: ['Dusty']\nbook.n.02_5: ['Dusty']\nbook.n.02_6: ['Dusty']\nbook.n.02_7: ['Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nshelf.n.01_1: ['Stained', 'Dusty']\ncarton.n.02_1: ['Open', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'book.n.02_1', 'floor.n.01_1']\n['onfloor', 'book.n.02_2', 'floor.n.01_1']\n['onfloor', 'book.n.02_3', 'floor.n.01_1']\n['onfloor', 'book.n.02_4', 'floor.n.01_1']\n['onfloor', 'book.n.02_5', 'floor.n.01_1']\n['ontop', 'book.n.02_6', 'shelf.n.01_1']\n['ontop', 'book.n.02_7', 'shelf.n.01_1']\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"boxing_books_up_for_storage\",\n    \"Goal Instructions\": \"Place the books into the carton for storage.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "bringing_in_wood_0_Benevolence_1_int_0_2021-09-15_18-42-25",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nplywood.n.01_1: ['Stained', 'Dusty']\nplywood.n.01_2: ['Stained', 'Dusty']\nplywood.n.01_3: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'plywood.n.01_1', 'floor.n.01_1']\n['onfloor', 'plywood.n.01_2', 'floor.n.01_1']\n['onfloor', 'plywood.n.01_3', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"bringing_in_wood\",\n    \"Goal Instructions\": \"Bring all plywood pieces inside and put them down.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "brushing_lint_off_clothing_0_Pomaria_2_int_0_2021-06-04_17-41-56",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nsweater.n.01_1: ['Stained', 'Dusty']\nsweater.n.01_2: ['Stained', 'Dusty']\nsweater.n.01_3: ['Stained', 'Dusty']\nsweater.n.01_4: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\nscrub_brush.n.01_1: ['Stained', 'Soaked', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'sweater.n.01_1', 'floor.n.01_1']\n['onfloor', 'sweater.n.01_2', 'floor.n.01_1']\n['ontop', 'sweater.n.01_3', 'bed.n.01_1']\n['ontop', 'sweater.n.01_4', 'bed.n.01_1']\n['dusty', 'sweater.n.01_1']\n['dusty', 'sweater.n.01_2']\n['dusty', 'sweater.n.01_3']\n['dusty', 'sweater.n.01_4']\n['onfloor', 'scrub_brush.n.01_1', 'floor.n.01_1']\n['not', 'dusty', 'scrub_brush.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"brushing_lint_off_clothing\",\n    \"Goal Instructions\": \"Check every sweater for lint, make sure none of them are dusty, and put them on the bed.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "chopping_vegetables_0_Rs_int_0_2021-05-25_22-01-16",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ntomato.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\ntomato.n.01_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nmushroom.n.05_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nmushroom.n.05_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nchestnut.n.03_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nchestnut.n.03_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\ncountertop.n.01_1: ['Stained', 'Dusty']\nvidalia_onion.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nvidalia_onion.n.01_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\nknife.n.01_1: ['Stained', 'Dusty']\ndish.n.01_1: ['Stained', 'Frozen', 'Cooked', 'Burnt']\ndish.n.01_2: ['Stained', 'Frozen', 'Cooked', 'Burnt']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'tomato.n.01_1', 'countertop.n.01_1']\n['ontop', 'tomato.n.01_2', 'countertop.n.01_1']\n['ontop', 'mushroom.n.05_1', 'countertop.n.01_1']\n['ontop', 'mushroom.n.05_2', 'countertop.n.01_1']\n['ontop', 'chestnut.n.03_1', 'countertop.n.01_1']\n['ontop', 'chestnut.n.03_2', 'countertop.n.01_1']\n['inside', 'vidalia_onion.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'vidalia_onion.n.01_2', 'electric_refrigerator.n.01_1']\n['ontop', 'knife.n.01_1', 'countertop.n.01_1']\n['inside', 'dish.n.01_1', 'cabinet.n.01_1']\n['inside', 'dish.n.01_2', 'cabinet.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"chopping_vegetables\",\n    \"Goal Instructions\": \"Slice all the vegetables, and put all sliced vegetable into dishes.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_a_car_0_Ihlen_0_int_0_2021-09-11_16-37-11",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncar.n.01_1: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\nshelf.n.01_1: ['Stained', 'Dusty']\nsoap.n.01_1: []\nbucket.n.01_1: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'car.n.01_1', 'floor.n.01_1']\n['ontop', 'rag.n.01_1', 'shelf.n.01_1']\n['not', 'soaked', 'rag.n.01_1']\n['ontop', 'soap.n.01_1', 'shelf.n.01_1']\n['dusty', 'car.n.01_1']\n['onfloor', 'bucket.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_a_car\",\n    \"Goal Instructions\": \"Use the soap, rag and bucket to clean dust off the car.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_barbecue_grill_0_Ihlen_0_int_0_2021-09-10_16-02-39",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ngrill.n.02_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\nbucket.n.01_1: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'grill.n.02_1', 'floor.n.01_1']\n['stained', 'grill.n.02_1']\n['dusty', 'grill.n.02_1']\n['ontop', 'bucket.n.01_1', 'table.n.02_1']\n['ontop', 'rag.n.01_1', 'table.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_barbecue_grill\",\n    \"Goal Instructions\": \"Clean stains and dust off of the barbecue grill.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_bathrooms_0_Benevolence_0_int_1_2021-06-12_19-33-28",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nbathtub.n.01_1: ['Stained', 'Dusty']\ntoilet.n.02_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nbucket.n.01_1: ['Stained', 'Dusty']\nsoap.n.01_1: []\nbrush.n.02_1: ['Stained', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\n\nAll initial states in the scene are:\n['stained', 'sink.n.01_1']\n['stained', 'bathtub.n.01_1']\n['stained', 'toilet.n.02_1']\n['stained', 'floor.n.01_1']\n['inside', 'soap.n.01_1', 'sink.n.01_1']\n['inside', 'brush.n.02_1', 'bathtub.n.01_1']\n['onfloor', 'bucket.n.01_1', 'floor.n.01_1']\n['not', 'soaked', 'rag.n.01_1']\n['onfloor', 'rag.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_bathrooms\",\n    \"Goal Instructions\": \"Use the rag and bucket to clean stains off the toilet, the bathtub, the sink, and the floor.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_bathtub_0_Pomaria_0_int_0_2021-09-10_16-22-10",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nbathtub.n.01_1: ['Stained', 'Dusty']\nsoap.n.01_1: []\nfloor.n.01_1: ['Stained', 'Dusty']\nbucket.n.01_1: ['Stained', 'Dusty']\nscrub_brush.n.01_1: ['Stained', 'Soaked', 'Dusty']\n\nAll initial states in the scene are:\n['stained', 'bathtub.n.01_1']\n['onfloor', 'soap.n.01_1', 'floor.n.01_1']\n['onfloor', 'bucket.n.01_1', 'floor.n.01_1']\n['inside', 'scrub_brush.n.01_1', 'bathtub.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_bathtub\",\n    \"Goal Instructions\": \"Clean the stained bathtub.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_bedroom_0_Benevolence_2_int_0_2021-06-06_18-10-59",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nfloor.n.01_1: ['Stained', 'Dusty']\napparel.n.01_1: ['Stained', 'Dusty']\napparel.n.01_2: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\njewelry.n.01_1: ['Stained', 'Dusty']\nperfume.n.02_1: ['Frozen']\npainting.n.01_1: ['Dusty']\nvacuum.n.04_1: ['ToggledOn', 'Stained', 'Dusty']\nhand_towel.n.01_1: ['Stained', 'Soaked', 'Dusty']\nsheet.n.03_1: ['Stained']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_2: ['Stained', 'Open', 'Dusty']\n\nAll initial states in the scene are:\n['dusty', 'cabinet.n.01_1']\n['dusty', 'cabinet.n.01_2']\n['ontop', 'apparel.n.01_1', 'bed.n.01_1']\n['ontop', 'apparel.n.01_2', 'bed.n.01_1']\n['onfloor', 'jewelry.n.01_1', 'floor.n.01_1']\n['onfloor', 'perfume.n.02_1', 'floor.n.01_1']\n['ontop', 'painting.n.01_1', 'bed.n.01_1']\n['not', 'dusty', 'vacuum.n.04_1']\n['onfloor', 'vacuum.n.04_1', 'floor.n.01_1']\n['onfloor', 'hand_towel.n.01_1', 'floor.n.01_1']\n['onfloor', 'sheet.n.03_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_bedroom\",\n    \"Goal Instructions\": \"Put clothes inside the cabinets, put jewelry and perfume inside the cabinet, place the sheet on the bed and the painting on top, clean the cabinets of any dust, place the vacuum next to the bed.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_carpets_0_Wainscott_1_int_0_2021-09-11_01-12-41",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\nhand_towel.n.01_1: ['Stained', 'Soaked', 'Dusty']\nshampoo.n.01_1: ['Frozen']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nwasher.n.03_1: ['Stained', 'Open', 'Dusty']\ndryer.n.01_1: ['ToggledOn', 'Stained', 'Open', 'Dusty']\ndoor.n.01_1: ['Stained', 'Open', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['stained', 'floor.n.01_1']\n['onfloor', 'hand_towel.n.01_1', 'floor.n.01_2']\n['inside', 'shampoo.n.01_1', 'cabinet.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_carpets\",\n    \"Goal Instructions\": \"Clean the stained carpets.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_closet_0_Beechwood_1_int_0_2021-10-25_19-50-32",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nshelf.n.01_1: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_2: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_3: ['Stained', 'Open', 'Dusty']\njewelry.n.01_1: ['Stained', 'Dusty']\njewelry.n.01_2: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\nhat.n.01_1: ['Stained', 'Dusty']\nsandal.n.01_1: ['Stained', 'Dusty']\nsandal.n.01_2: ['Stained', 'Dusty']\numbrella.n.01_1: ['Stained', 'Dusty']\ntowel.n.01_1: ['Stained', 'Soaked', 'Dusty']\n\nAll initial states in the scene are:\n['dusty', 'shelf.n.01_1']\n['dusty', 'cabinet.n.01_3']\n['onfloor', 'jewelry.n.01_1', 'floor.n.01_1']\n['onfloor', 'jewelry.n.01_2', 'floor.n.01_1']\n['dusty', 'floor.n.01_1']\n['onfloor', 'hat.n.01_1', 'floor.n.01_1']\n['onfloor', 'sandal.n.01_1', 'floor.n.01_1']\n['onfloor', 'sandal.n.01_2', 'floor.n.01_1']\n['onfloor', 'umbrella.n.01_1', 'floor.n.01_1']\n['inside', 'towel.n.01_1', 'cabinet.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_2']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_closet\",\n    \"Goal Instructions\": \"Organize all jewelry inside cabinet3, make sure umbrella1 is not inside cabinet3, place hat1 inside the cabinet or on top of shelf1, place all sandals next to shelf1 and on the floor, clean dust from cabinet3, shelf1, and floor1.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_cupboards_0_Wainscott_1_int_1_2021-08-25_16-40-44",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbook.n.02_1: ['Dusty']\nbook.n.02_2: ['Dusty']\nbook.n.02_3: ['Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_2: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_3: ['Stained', 'Open', 'Dusty']\npen.n.01_1: ['Stained', 'Dusty']\nmarker.n.03_1: ['Stained', 'Dusty']\nmarker.n.03_2: ['Stained', 'Dusty']\nscrewdriver.n.01_1: ['Stained', 'Dusty']\nscrub_brush.n.01_1: ['Stained', 'Soaked', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\ncleansing_agent.n.01_1: ['Frozen']\nbin.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nbucket.n.01_1: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['inside', 'book.n.02_1', 'cabinet.n.01_1']\n['inside', 'book.n.02_2', 'cabinet.n.01_2']\n['inside', 'book.n.02_3', 'cabinet.n.01_2']\n['inside', 'pen.n.01_1', 'cabinet.n.01_1']\n['inside', 'marker.n.03_1', 'cabinet.n.01_2']\n['inside', 'marker.n.03_2', 'cabinet.n.01_2']\n['inside', 'screwdriver.n.01_1', 'cabinet.n.01_3']\n['inside', 'scrub_brush.n.01_1', 'cabinet.n.01_1']\n['inside', 'rag.n.01_1', 'cabinet.n.01_1']\n['ontop', 'cleansing_agent.n.01_1', 'bed.n.01_1']\n['onfloor', 'bin.n.01_1', 'floor.n.01_1']\n['ontop', 'bucket.n.01_1', 'bed.n.01_1']\n['dusty', 'cabinet.n.01_1']\n['dusty', 'cabinet.n.01_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_cupboards\",\n    \"Goal Instructions\": \"Clean dusty cabinets, remove all books from the cabinets, put the screwdriver in the bin, put all markers and pens in the bucket.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_floors_0_Merom_0_int_1_2021-06-23_16-12-28",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nfloor.n.01_1: ['Stained', 'Dusty']\nbroom.n.01_1: ['Dusty']\ndustpan.n.02_1: ['Stained', 'Dusty']\ncleansing_agent.n.01_1: ['Frozen']\nscrub_brush.n.01_1: ['Stained', 'Soaked', 'Dusty']\ndoor.n.01_1: ['Stained', 'Open', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['dusty', 'floor.n.01_1']\n['stained', 'floor.n.01_1']\n['onfloor', 'broom.n.01_1', 'floor.n.01_1']\n['onfloor', 'dustpan.n.02_1', 'floor.n.01_1']\n['onfloor', 'cleansing_agent.n.01_1', 'floor.n.01_1']\n['onfloor', 'scrub_brush.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_floors\",\n    \"Goal Instructions\": \"Clean dust and stains off the floors.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_freezer_0_Pomaria_1_int_0_2021-10-26_12-59-25",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\nfood.n.01_1: ['Frozen']\nfood.n.01_2: ['Frozen']\nfood.n.01_3: ['Frozen']\ncleansing_agent.n.01_1: ['Frozen']\ntable.n.02_1: ['Stained', 'Dusty']\ntowel.n.01_1: ['Stained', 'Soaked', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\nstove.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\ndoor.n.01_1: ['Stained', 'Open', 'Dusty']\nchair.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['stained', 'electric_refrigerator.n.01_1']\n['inside', 'food.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'food.n.01_2', 'electric_refrigerator.n.01_1']\n['inside', 'food.n.01_3', 'electric_refrigerator.n.01_1']\n['ontop', 'cleansing_agent.n.01_1', 'table.n.02_1']\n['ontop', 'towel.n.01_1', 'table.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_freezer\",\n    \"Goal Instructions\": \"Clean the stained freezer and remove all food items from the freezer.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_garage_0_Ihlen_0_int_0_2021-08-24_17-40-48",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbox.n.01_1: ['Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\nnewspaper.n.03_1: ['Dusty']\nnewspaper.n.03_2: ['Dusty']\nbottle.n.01_1: ['Stained', 'Dusty']\nbottle.n.01_2: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nbroom.n.01_1: ['Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\ntable.n.02_1: ['Stained', 'Dusty']\nbin.n.01_1: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nshelf.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'box.n.01_1', 'floor.n.01_1']\n['onfloor', 'newspaper.n.03_1', 'floor.n.01_1']\n['onfloor', 'newspaper.n.03_2', 'floor.n.01_1']\n['onfloor', 'bottle.n.01_1', 'floor.n.01_1']\n['onfloor', 'bottle.n.01_2', 'floor.n.01_1']\n['dusty', 'floor.n.01_1']\n['stained', 'floor.n.01_1']\n['dusty', 'cabinet.n.01_1']\n['onfloor', 'broom.n.01_1', 'floor.n.01_1']\n['ontop', 'rag.n.01_1', 'table.n.02_1']\n['onfloor', 'bin.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_2']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_garage\",\n    \"Goal Instructions\": \"Clean dust and stains off the floor and cabinet, put all newspapers into the bin or on the floor, and put all bottles on the table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_high_chair_0_Wainscott_0_int_0_2021-06-05_18-03-15",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nhighchair.n.01_1: ['Stained', 'Dusty']\npiece_of_cloth.n.01_1: ['Stained', 'Soaked', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['dusty', 'highchair.n.01_1']\n['inside', 'piece_of_cloth.n.01_1', 'cabinet.n.01_1']\n['onfloor', 'highchair.n.01_1', 'floor.n.01_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_high_chair\",\n    \"Goal Instructions\": \"Clean the high chair.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_kitchen_cupboard_0_Pomaria_1_int_0_2021-10-26_13-05-36",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_2: ['Stained', 'Open', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\npiece_of_cloth.n.01_1: ['Stained', 'Soaked', 'Dusty']\ncleansing_agent.n.01_1: []\nbowl.n.01_1: ['Stained', 'Dusty']\nbowl.n.01_2: ['Stained', 'Dusty']\ncup.n.01_1: ['Stained', 'Dusty']\ncup.n.01_2: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['dusty', 'cabinet.n.01_1']\n['dusty', 'cabinet.n.01_2']\n['ontop', 'piece_of_cloth.n.01_1', 'countertop.n.01_1']\n['ontop', 'cleansing_agent.n.01_1', 'countertop.n.01_1']\n['inside', 'bowl.n.01_2', 'cabinet.n.01_2']\n['inside', 'cup.n.01_1', 'cabinet.n.01_2']\n['inside', 'cup.n.01_2', 'cabinet.n.01_1']\n['ontop', 'bowl.n.01_1', 'countertop.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_kitchen_cupboard\",\n    \"Goal Instructions\": \"Clean all dusty cabinets, put all bowls in one cabinet and all cups in another.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_microwave_oven_0_Benevolence_1_int_0_2021-09-11_01-27-10",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nmicrowave.n.02_1: ['ToggledOn', 'Stained', 'Open', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\ncountertop.n.01_1: ['Stained', 'Dusty']\nashcan.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['dusty', 'microwave.n.02_1']\n['stained', 'microwave.n.02_1']\n['ontop', 'rag.n.01_1', 'countertop.n.01_1']\n['onfloor', 'ashcan.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_microwave_oven\",\n    \"Goal Instructions\": \"Clean the microwave oven.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_out_drawers_0_Benevolence_1_int_0_2021-10-20_05-03-27",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbowl.n.01_1: ['Stained', 'Dusty']\nbowl.n.01_2: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_2: ['Stained', 'Open', 'Dusty']\nspoon.n.01_1: ['Stained', 'Dusty']\nspoon.n.01_2: ['Stained', 'Dusty']\npiece_of_cloth.n.01_1: ['Stained', 'Soaked', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['inside', 'bowl.n.01_1', 'cabinet.n.01_1']\n['inside', 'bowl.n.01_2', 'cabinet.n.01_1']\n['inside', 'spoon.n.01_1', 'cabinet.n.01_2']\n['inside', 'spoon.n.01_2', 'cabinet.n.01_2']\n['inside', 'piece_of_cloth.n.01_1', 'cabinet.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_out_drawers\",\n    \"Goal Instructions\": \"Remove the piece of cloth, two bowls, and two spoons from the drawers and put them near the sink.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_oven_0_Benevolence_1_int_0_2021-09-11_12-20-40",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nreceptacle.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nsoap.n.01_1: []\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\nrag.n.01_2: ['Stained', 'Soaked']\nnewspaper.n.03_1: ['Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nscrub_brush.n.01_1: ['Stained', 'Soaked', 'Dusty']\noven.n.01_1: ['ToggledOn', 'Stained', 'Open', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'receptacle.n.01_1', 'floor.n.01_1']\n['inside', 'soap.n.01_1', 'cabinet.n.01_1']\n['inside', 'rag.n.01_1', 'cabinet.n.01_1']\n['inside', 'rag.n.01_2', 'cabinet.n.01_1']\n['not', 'soaked', 'rag.n.01_1']\n['not', 'soaked', 'rag.n.01_2']\n['onfloor', 'newspaper.n.03_1', 'floor.n.01_1']\n['inside', 'scrub_brush.n.01_1', 'cabinet.n.01_1']\n['not', 'soaked', 'scrub_brush.n.01_1']\n['stained', 'oven.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_oven\",\n    \"Goal Instructions\": \"Clean the oven using wet rags and scrub brushes.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_shoes_0_Pomaria_2_int_0_2021-09-11_13-59-22",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nsoap.n.01_1: []\nbed.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\ntowel.n.01_1: ['Stained', 'Soaked', 'Dusty']\nshoe.n.01_1: ['Stained', 'Dusty']\nshoe.n.01_2: ['Stained', 'Dusty']\nshoe.n.01_3: ['Stained', 'Dusty']\nshoe.n.01_4: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'soap.n.01_1', 'bed.n.01_1']\n['ontop', 'rag.n.01_1', 'bed.n.01_1']\n['onfloor', 'towel.n.01_1', 'floor.n.01_1']\n['ontop', 'shoe.n.01_1', 'bed.n.01_1']\n['ontop', 'shoe.n.01_2', 'bed.n.01_1']\n['ontop', 'shoe.n.01_3', 'bed.n.01_1']\n['ontop', 'shoe.n.01_4', 'bed.n.01_1']\n['stained', 'shoe.n.01_1']\n['stained', 'shoe.n.01_2']\n['dusty', 'shoe.n.01_3']\n['dusty', 'shoe.n.01_4']\n['not', 'soaked', 'rag.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_shoes\",\n    \"Goal Instructions\": \"Clean all the shoes, and leave the towel on the floor.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_sneakers_0_Pomaria_1_int_0_2021-10-26_13-36-08",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ngym_shoe.n.01_1: ['Stained', 'Dusty']\ngym_shoe.n.01_2: ['Stained', 'Dusty']\ngym_shoe.n.01_3: ['Stained', 'Dusty']\ngym_shoe.n.01_4: ['Stained', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\nsoap.n.01_1: []\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ntowel.n.01_1: ['Stained', 'Soaked', 'Dusty']\nbrush.n.02_1: ['Stained', 'Soaked', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'gym_shoe.n.01_1', 'floor.n.01_2']\n['stained', 'gym_shoe.n.01_1']\n['onfloor', 'gym_shoe.n.01_2', 'floor.n.01_2']\n['stained', 'gym_shoe.n.01_2']\n['onfloor', 'gym_shoe.n.01_3', 'floor.n.01_2']\n['dusty', 'gym_shoe.n.01_3']\n['onfloor', 'gym_shoe.n.01_4', 'floor.n.01_2']\n['dusty', 'gym_shoe.n.01_4']\n['inside', 'soap.n.01_1', 'cabinet.n.01_1']\n['ontop', 'towel.n.01_1', 'countertop.n.01_1']\n['not', 'stained', 'towel.n.01_1']\n['ontop', 'brush.n.02_1', 'countertop.n.01_1']\n['not', 'stained', 'brush.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_2']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_sneakers\",\n    \"Goal Instructions\": \"Place the towel on the countertop, the brush next to the towel, and the soap into the sink. Clean the dusty and stained sneakers, place 2 sneakers next to the table and 2 other sneakers under the table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_stove_0_Wainscott_0_int_0_2021-09-11_12-51-07",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nstove.n.01_1: ['ToggledOn', 'Stained', 'Open', 'Dusty']\nsoap.n.01_1: []\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\ndishtowel.n.01_1: ['Stained', 'Soaked']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['dusty', 'stove.n.01_1']\n['stained', 'stove.n.01_1']\n['inside', 'soap.n.01_1', 'cabinet.n.01_1']\n['inside', 'rag.n.01_1', 'cabinet.n.01_1']\n['not', 'soaked', 'rag.n.01_1']\n['not', 'stained', 'rag.n.01_1']\n['inside', 'dishtowel.n.01_1', 'cabinet.n.01_1']\n['not', 'soaked', 'dishtowel.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_stove\",\n    \"Goal Instructions\": \"Use the rag and dishtowel to clean the dusty and stained stove, then leave them next to the sink.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_table_after_clearing_0_Merom_1_int_0_2021-06-06_19-48-44",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ntable.n.02_1: ['Stained', 'Dusty']\nsoap.n.01_1: []\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ndishtowel.n.01_1: ['Stained', 'Soaked']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\n\nAll initial states in the scene are:\n['stained', 'table.n.02_1']\n['inside', 'soap.n.01_1', 'cabinet.n.01_1']\n['inside', 'dishtowel.n.01_1', 'cabinet.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_table_after_clearing\",\n    \"Goal Instructions\": \"Clean the table after clearing it.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_the_hot_tub_0_Ihlen_0_int_0_2021-08-24_22-19-07",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\npool.n.01_1: ['Stained', 'Frozen']\nfloor.n.01_1: ['Stained', 'Dusty']\nscrub_brush.n.01_1: ['Stained', 'Soaked', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'pool.n.01_1', 'floor.n.01_1']\n['stained', 'pool.n.01_1']\n['onfloor', 'scrub_brush.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_the_hot_tub\",\n    \"Goal Instructions\": \"Clean the stained hot tub located on floor1.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_the_pool_0_Ihlen_0_int_0_2021-06-01_15-30-31",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\npool.n.01_1: ['Stained', 'Frozen']\nfloor.n.01_1: ['Stained', 'Dusty']\nscrub_brush.n.01_1: ['Stained', 'Soaked', 'Dusty']\nshelf.n.01_1: ['Stained', 'Dusty']\ndetergent.n.02_1: ['Frozen']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'pool.n.01_1', 'floor.n.01_1']\n['stained', 'pool.n.01_1']\n['onfloor', 'scrub_brush.n.01_1', 'floor.n.01_1']\n['onfloor', 'detergent.n.02_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_the_pool\",\n    \"Goal Instructions\": \"Clean the stained pool on the floor using the scrub brush and the detergent, when you are done leave the brush on top of the shelf, and the detergent on the floor.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_toilet_0_Merom_0_int_1_2021-06-23_17-35-48",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ntoilet.n.02_1: ['Stained', 'Dusty']\nscrub_brush.n.01_1: ['Stained', 'Soaked', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ndetergent.n.02_1: ['Frozen']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['stained', 'toilet.n.02_1']\n['onfloor', 'scrub_brush.n.01_1', 'floor.n.01_1']\n['onfloor', 'detergent.n.02_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_toilet\",\n    \"Goal Instructions\": \"Use the scrub brush and detergent to clean the stained toilet, and leave them on the floor when finished.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_up_after_a_meal_0_Merom_1_int_0_2021-06-06_19-55-27",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbowl.n.01_1: ['Stained', 'Dusty']\nbowl.n.01_2: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nsack.n.01_1: ['Stained']\nchair.n.01_1: ['Stained', 'Dusty']\nchair.n.01_2: ['Stained', 'Dusty']\nplate.n.04_1: ['Stained', 'Dusty']\nplate.n.04_2: ['Stained', 'Dusty']\nplate.n.04_3: ['Stained', 'Dusty']\nplate.n.04_4: ['Stained', 'Dusty']\ncup.n.01_1: ['Stained', 'Dusty']\ncup.n.01_2: ['Stained', 'Dusty']\nhamburger.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nhamburger.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\ndetergent.n.02_1: ['Frozen']\ndishwasher.n.01_1: ['ToggledOn', 'Stained', 'Open', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'bowl.n.01_1', 'table.n.02_1']\n['ontop', 'bowl.n.01_2', 'table.n.02_1']\n['stained', 'bowl.n.01_1']\n['stained', 'bowl.n.01_2']\n['ontop', 'sack.n.01_1', 'table.n.02_1']\n['ontop', 'plate.n.04_1', 'table.n.02_1']\n['ontop', 'plate.n.04_2', 'table.n.02_1']\n['ontop', 'plate.n.04_3', 'table.n.02_1']\n['ontop', 'plate.n.04_4', 'table.n.02_1']\n['stained', 'plate.n.04_1']\n['stained', 'plate.n.04_2']\n['stained', 'plate.n.04_3']\n['stained', 'plate.n.04_4']\n['ontop', 'cup.n.01_1', 'table.n.02_1']\n['ontop', 'cup.n.01_2', 'table.n.02_1']\n['stained', 'cup.n.01_1']\n['stained', 'cup.n.01_2']\n['ontop', 'hamburger.n.01_1', 'chair.n.01_2']\n['onfloor', 'hamburger.n.01_2', 'floor.n.01_1']\n['onfloor', 'detergent.n.02_1', 'floor.n.01_1']\n['stained', 'chair.n.01_1']\n['stained', 'chair.n.01_2']\n['stained', 'table.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_2']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_up_after_a_meal\",\n    \"Goal Instructions\": \"Clean all the stained tableware, put all hamburgers into sack1 which is on the floor, and clean the stained floor, chair, and table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_up_refrigerator_0_Wainscott_0_int_1_2021-06-23_17-46-01",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nrag.n.01_1: ['Stained', 'Soaked']\nrag.n.01_2: ['Stained', 'Soaked']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nsoap.n.01_1: []\ncountertop.n.01_1: ['Stained', 'Dusty']\ntray.n.01_1: ['Stained', 'Dusty']\ntray.n.01_2: ['Stained', 'Dusty']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\nbowl.n.01_1: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['inside', 'rag.n.01_1', 'cabinet.n.01_1']\n['inside', 'rag.n.01_2', 'cabinet.n.01_1']\n['ontop', 'soap.n.01_1', 'countertop.n.01_1']\n['inside', 'tray.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'tray.n.01_2', 'electric_refrigerator.n.01_1']\n['inside', 'bowl.n.01_1', 'electric_refrigerator.n.01_1']\n['not', 'soaked', 'rag.n.01_1']\n['not', 'soaked', 'rag.n.01_2']\n['stained', 'tray.n.01_1']\n['stained', 'tray.n.01_2']\n['dusty', 'bowl.n.01_1']\n['stained', 'electric_refrigerator.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_up_refrigerator\",\n    \"Goal Instructions\": \"Use the rag and soap to clean the trays, the bowl, and the refrigerator. When you are done, leave the rag and bowl next to the sink, the soap in the sink, and the trays in the refrigerator.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_up_the_kitchen_only_0_Pomaria_1_int_0_2021-10-26_00-50-16",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbin.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nsoap.n.01_1: []\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_2: ['Stained', 'Open', 'Dusty']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\ndustpan.n.02_1: ['Stained', 'Dusty']\nbroom.n.01_1: ['Dusty']\nblender.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\ncasserole.n.02_1: ['Stained', 'Frozen', 'Cooked', 'Burnt']\nplate.n.04_1: ['Stained', 'Dusty']\nvegetable_oil.n.01_1: ['Frozen', 'Cooked', 'Burnt']\napple.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nwindow.n.01_1: ['Stained', 'Open', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'bin.n.01_1', 'floor.n.01_1']\n['inside', 'soap.n.01_1', 'cabinet.n.01_1']\n['inside', 'rag.n.01_1', 'cabinet.n.01_1']\n['not', 'soaked', 'rag.n.01_1']\n['inside', 'dustpan.n.02_1', 'cabinet.n.01_1']\n['dusty', 'dustpan.n.02_1']\n['onfloor', 'broom.n.01_1', 'floor.n.01_1']\n['dusty', 'broom.n.01_1']\n['onfloor', 'blender.n.01_1', 'floor.n.01_1']\n['stained', 'blender.n.01_1']\n['inside', 'casserole.n.02_1', 'electric_refrigerator.n.01_1']\n['inside', 'plate.n.04_1', 'electric_refrigerator.n.01_1']\n['stained', 'plate.n.04_1']\n['inside', 'vegetable_oil.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'apple.n.01_1', 'electric_refrigerator.n.01_1']\n['dusty', 'floor.n.01_1']\n['dusty', 'cabinet.n.01_1']\n['dusty', 'cabinet.n.01_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_up_the_kitchen_only\",\n    \"Goal Instructions\": \"Use the soap and rags to clean the plates, cabinets and floor, then leave the soap and rags near the sink. Place the blender on the countertop, store vegetable oil in one cabinet and plates in another cabinet, and put the fuits and vegetables in the fridge.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "cleaning_windows_0_Wainscott_0_int_0_2021-05-23_23-07-05",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ntowel.n.01_1: ['Stained', 'Soaked']\ntowel.n.01_2: ['Stained', 'Soaked']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\nrag.n.01_2: ['Stained', 'Soaked']\ncleansing_agent.n.01_1: ['Frozen']\nwindow.n.01_1: ['Stained', 'Open', 'Dusty']\nwindow.n.01_2: ['Stained', 'Open', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['inside', 'towel.n.01_1', 'cabinet.n.01_1']\n['inside', 'towel.n.01_2', 'cabinet.n.01_1']\n['inside', 'rag.n.01_1', 'cabinet.n.01_1']\n['inside', 'rag.n.01_2', 'cabinet.n.01_1']\n['not', 'soaked', 'rag.n.01_1']\n['not', 'soaked', 'rag.n.01_2']\n['inside', 'cleansing_agent.n.01_1', 'cabinet.n.01_1']\n['dusty', 'window.n.01_1']\n['dusty', 'window.n.01_2']\n['not', 'dusty', 'sink.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"cleaning_windows\",\n    \"Goal Instructions\": \"Soak the rags and use them to clean the dusty windows.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "clearing_the_table_after_dinner_0_Ihlen_0_int_0_2021-10-25_23-01-51",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nfloor.n.01_1: ['Stained', 'Dusty']\nchair.n.01_1: ['Stained', 'Dusty']\nchair.n.01_2: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\ncup.n.01_1: ['Stained', 'Dusty']\ncup.n.01_2: ['Stained', 'Dusty']\nbucket.n.01_1: ['Stained', 'Dusty']\nbucket.n.01_2: ['Stained', 'Dusty']\nbowl.n.01_1: ['Stained', 'Dusty']\nbowl.n.01_2: ['Stained', 'Dusty']\nbowl.n.01_3: ['Stained', 'Dusty']\nbowl.n.01_4: ['Stained', 'Dusty']\ncatsup.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nbeverage.n.01_1: ['Frozen']\nbeverage.n.01_2: ['Frozen']\n\nAll initial states in the scene are:\n['ontop', 'cup.n.01_1', 'table.n.02_1']\n['ontop', 'cup.n.01_2', 'table.n.02_1']\n['onfloor', 'bucket.n.01_1', 'floor.n.01_1']\n['ontop', 'bowl.n.01_1', 'table.n.02_1']\n['ontop', 'bowl.n.01_2', 'table.n.02_1']\n['ontop', 'bowl.n.01_3', 'table.n.02_1']\n['ontop', 'bowl.n.01_4', 'table.n.02_1']\n['ontop', 'catsup.n.01_1', 'table.n.02_1']\n['ontop', 'beverage.n.01_1', 'table.n.02_1']\n['onfloor', 'beverage.n.01_2', 'floor.n.01_1']\n['onfloor', 'bucket.n.01_2', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"clearing_the_table_after_dinner\",\n    \"Goal Instructions\": \"Put all cups, bowls, and catsup into buckets.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "collect_misplaced_items_0_Wainscott_0_int_1_2021-10-26_18-48-11",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ngym_shoe.n.01_1: ['Stained', 'Dusty']\nnecklace.n.01_1: ['Stained', 'Dusty']\nnotebook.n.01_1: ['Dusty']\nsock.n.01_1: ['Stained', 'Dusty']\nsock.n.01_2: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\ntable.n.02_2: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nsofa.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['under', 'gym_shoe.n.01_1', 'table.n.02_1']\n['onfloor', 'gym_shoe.n.01_1', 'floor.n.01_2']\n['inside', 'necklace.n.01_1', 'cabinet.n.01_1']\n['under', 'notebook.n.01_1', 'table.n.02_2']\n['ontop', 'sock.n.01_1', 'sofa.n.01_1']\n['onfloor', 'sock.n.01_2', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"collect_misplaced_items\",\n    \"Goal Instructions\": \"Collect all misplaced items including the gym shoe, necklace, notebook, and socks. Then place them on the table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "collecting_aluminum_cans_0_Ihlen_1_int_0_2021-06-06_20-13-28",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\npop.n.02_1: ['Frozen']\npop.n.02_2: ['Frozen']\npop.n.02_3: ['Frozen']\npop.n.02_4: ['Frozen']\npop.n.02_5: ['Frozen']\npop.n.02_6: ['Frozen']\nbed.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nbucket.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'pop.n.02_1', 'bed.n.01_1']\n['ontop', 'pop.n.02_2', 'bed.n.01_1']\n['ontop', 'pop.n.02_3', 'bed.n.01_1']\n['onfloor', 'pop.n.02_4', 'floor.n.01_1']\n['onfloor', 'pop.n.02_5', 'floor.n.01_1']\n['onfloor', 'pop.n.02_6', 'floor.n.01_1']\n['ontop', 'bucket.n.01_1', 'bed.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"collecting_aluminum_cans\",\n    \"Goal Instructions\": \"Collect all aluminum cans and place them into the bucket.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "defrosting_freezer_0_Beechwood_0_int_0_2021-10-25_23-10-43",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nfloor.n.01_1: ['Stained', 'Dusty']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\nreceptacle.n.01_1: ['Stained', 'Dusty']\nbucket.n.01_1: ['Stained', 'Dusty']\nscraper.n.01_1: ['Stained']\ntowel.n.01_1: ['Stained', 'Soaked', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\nfood.n.02_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nfood.n.02_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nfood.n.02_3: ['Frozen', 'Cooked', 'Burnt']\n\nAll initial states in the scene are:\n['not', 'stained', 'sink.n.01_1']\n['onfloor', 'receptacle.n.01_1', 'floor.n.01_1']\n['onfloor', 'bucket.n.01_1', 'floor.n.01_1']\n['ontop', 'scraper.n.01_1', 'countertop.n.01_1']\n['ontop', 'towel.n.01_1', 'countertop.n.01_1']\n['not', 'stained', 'towel.n.01_1']\n['ontop', 'rag.n.01_1', 'countertop.n.01_1']\n['not', 'soaked', 'rag.n.01_1']\n['inside', 'food.n.02_1', 'electric_refrigerator.n.01_1']\n['inside', 'food.n.02_2', 'electric_refrigerator.n.01_1']\n['inside', 'food.n.02_3', 'electric_refrigerator.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"defrosting_freezer\",\n    \"Goal Instructions\": \"Place the receptacle next to the refrigerator, the bucket next to the countertop, the scraper on top of the refrigerator, the towel on the countertop, the soaked rag inside the sink, and all the food inside the bucket.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "filling_a_Christmas_stocking_0_Rs_int_0_2021-06-04_18-47-42",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncube.n.05_1: []\ncube.n.05_2: []\ncube.n.05_3: []\ncube.n.05_4: []\nfloor.n.01_1: ['Stained', 'Dusty']\ncandy.n.01_1: ['Cooked', 'Burnt']\ncandy.n.01_2: ['Cooked', 'Burnt']\ncandy.n.01_3: ['Cooked', 'Burnt']\ncandy.n.01_4: ['Cooked', 'Burnt']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_2: ['Stained', 'Open', 'Dusty']\npen.n.01_1: ['Stained', 'Dusty']\npen.n.01_2: ['Stained', 'Dusty']\npen.n.01_3: ['Stained', 'Dusty']\npen.n.01_4: ['Stained', 'Dusty']\nstocking.n.01_1: ['Stained']\nstocking.n.01_2: ['Stained']\nstocking.n.01_3: ['Stained']\nstocking.n.01_4: ['Stained']\n\nAll initial states in the scene are:\n['onfloor', 'cube.n.05_1', 'floor.n.01_1']\n['onfloor', 'cube.n.05_2', 'floor.n.01_1']\n['onfloor', 'cube.n.05_3', 'floor.n.01_1']\n['onfloor', 'cube.n.05_4', 'floor.n.01_1']\n['inside', 'candy.n.01_1', 'cabinet.n.01_1']\n['inside', 'candy.n.01_2', 'cabinet.n.01_1']\n['inside', 'candy.n.01_3', 'cabinet.n.01_1']\n['inside', 'candy.n.01_4', 'cabinet.n.01_1']\n['inside', 'pen.n.01_1', 'cabinet.n.01_1']\n['inside', 'pen.n.01_2', 'cabinet.n.01_1']\n['inside', 'pen.n.01_3', 'cabinet.n.01_1']\n['inside', 'pen.n.01_4', 'cabinet.n.01_1']\n['onfloor', 'stocking.n.01_1', 'floor.n.01_1']\n['onfloor', 'stocking.n.01_2', 'floor.n.01_1']\n['onfloor', 'stocking.n.01_3', 'floor.n.01_1']\n['onfloor', 'stocking.n.01_4', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"filling_a_Christmas_stocking\",\n    \"Goal Instructions\": \"Fill each stocking with one cube, one candy, and one pen.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "filling_an_Easter_basket_0_Benevolence_1_int_1_2021-09-10_00-09-54",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbasket.n.01_1: ['Stained', 'Dusty']\nbasket.n.01_2: ['Stained', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\nball.n.01_1: ['Stained', 'Dusty']\njewelry.n.01_1: ['Stained', 'Dusty']\nbook.n.02_1: ['Dusty']\nbook.n.02_2: ['Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_2: ['Stained', 'Open', 'Dusty']\nbow.n.08_1: ['Dusty']\nbow.n.08_2: ['Dusty']\negg.n.02_1: ['Frozen', 'Cooked', 'Burnt']\negg.n.02_2: ['Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\ncandy.n.01_1: ['Cooked', 'Burnt']\ncandy.n.01_2: ['Cooked', 'Burnt']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'basket.n.01_1', 'countertop.n.01_1']\n['ontop', 'basket.n.01_2', 'countertop.n.01_1']\n['ontop', 'ball.n.01_1', 'countertop.n.01_1']\n['ontop', 'jewelry.n.01_1', 'countertop.n.01_1']\n['inside', 'book.n.02_1', 'cabinet.n.01_1']\n['inside', 'book.n.02_2', 'cabinet.n.01_1']\n['inside', 'bow.n.08_1', 'cabinet.n.01_2']\n['inside', 'bow.n.08_2', 'cabinet.n.01_2']\n['inside', 'egg.n.02_1', 'electric_refrigerator.n.01_1']\n['cooked', 'egg.n.02_1']\n['inside', 'egg.n.02_2', 'electric_refrigerator.n.01_1']\n['cooked', 'egg.n.02_2']\n['ontop', 'candy.n.01_1', 'electric_refrigerator.n.01_1']\n['ontop', 'candy.n.01_2', 'electric_refrigerator.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"filling_an_Easter_basket\",\n    \"Goal Instructions\": \"Place eggs, candies, jewelry, balls, bows, and books in the baskets on the countertop.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "installing_a_fax_machine_0_Beechwood_0_int_0_2021-10-25_20-22-22",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nfacsimile.n.02_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'facsimile.n.02_1', 'floor.n.01_1']\n['not', 'toggled_on', 'facsimile.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"installing_a_fax_machine\",\n    \"Goal Instructions\": \"Place the fax machine on the table and turn it on.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "installing_a_modem_0_Beechwood_0_int_0_2021-10-25_20-28-55",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nmodem.n.01_1: ['ToggledOn', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['not', 'toggled_on', 'modem.n.01_1']\n['ontop', 'modem.n.01_1', 'table.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"installing_a_modem\",\n    \"Goal Instructions\": \"Place the modem under the table and make sure it is turned on.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "installing_a_printer_0_Pomaria_0_int_0_2021-06-08_18-33-07",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nprinter.n.03_1: ['ToggledOn', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'printer.n.03_1', 'floor.n.01_1']\n['not', 'toggled_on', 'printer.n.03_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"installing_a_printer\",\n    \"Goal Instructions\": \"Place the printer on the table and turn it on.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "installing_a_scanner_0_Pomaria_0_int_0_2021-06-08_18-34-59",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nscanner.n.02_1: ['ToggledOn', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'scanner.n.02_1', 'table.n.02_1']\n['not', 'toggled_on', 'scanner.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"installing_a_scanner\",\n    \"Goal Instructions\": \"Turn on the scanner and place it under the table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "installing_alarms_0_Merom_1_int_0_2021-05-23_23-02-24",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nalarm.n.02_1: ['ToggledOn', 'Stained', 'Dusty']\nalarm.n.02_2: ['ToggledOn', 'Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\ntable.n.02_2: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'alarm.n.02_1', 'table.n.02_2']\n['ontop', 'alarm.n.02_2', 'table.n.02_2']\n['not', 'toggled_on', 'alarm.n.02_1']\n['not', 'toggled_on', 'alarm.n.02_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"installing_alarms\",\n    \"Goal Instructions\": \"Place each alarm on a table and make sure they are turned on.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "laying_tile_floors_0_Beechwood_0_int_0_2021-10-26_17-26-23",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ntile.n.01_1: ['Stained', 'Dusty']\ntile.n.01_2: ['Stained', 'Dusty']\ntile.n.01_3: ['Stained', 'Dusty']\ntile.n.01_4: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'tile.n.01_1', 'floor.n.01_1']\n['onfloor', 'tile.n.01_2', 'floor.n.01_1']\n['onfloor', 'tile.n.01_3', 'floor.n.01_1']\n['onfloor', 'tile.n.01_4', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"laying_tile_floors\",\n    \"Goal Instructions\": \"Lay all the tiles on the floor.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "laying_wood_floors_0_Pomaria_1_int_0_2021-10-25_20-46-59",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nplywood.n.01_1: ['Stained', 'Dusty']\nplywood.n.01_2: ['Stained', 'Dusty']\nplywood.n.01_3: ['Stained', 'Dusty']\nplywood.n.01_4: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\nhammer.n.02_1: ['Stained', 'Dusty']\nsaw.n.02_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'plywood.n.01_1', 'floor.n.01_1']\n['onfloor', 'plywood.n.01_2', 'floor.n.01_1']\n['onfloor', 'plywood.n.01_3', 'floor.n.01_1']\n['onfloor', 'plywood.n.01_4', 'floor.n.01_1']\n['onfloor', 'hammer.n.02_1', 'floor.n.01_1']\n['onfloor', 'saw.n.02_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"laying_wood_floors\",\n    \"Goal Instructions\": \"Lay the plywoods on floor2 right next to each other.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "loading_the_dishwasher_0_Benevolence_1_int_0_2021-10-20_06-10-42",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nplate.n.04_1: ['Stained', 'Dusty']\nplate.n.04_2: ['Stained', 'Dusty']\nplate.n.04_3: ['Stained', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\nmug.n.04_1: ['Stained', 'Dusty']\nbowl.n.01_1: ['Stained', 'Dusty']\nbowl.n.01_2: ['Stained', 'Dusty']\ndishwasher.n.01_1: ['ToggledOn', 'Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'plate.n.04_1', 'countertop.n.01_1']\n['stained', 'plate.n.04_1']\n['ontop', 'plate.n.04_2', 'countertop.n.01_1']\n['stained', 'plate.n.04_2']\n['ontop', 'plate.n.04_3', 'countertop.n.01_1']\n['stained', 'plate.n.04_3']\n['ontop', 'mug.n.04_1', 'countertop.n.01_1']\n['stained', 'mug.n.04_1']\n['ontop', 'bowl.n.01_1', 'countertop.n.01_1']\n['stained', 'bowl.n.01_1']\n['ontop', 'bowl.n.01_2', 'countertop.n.01_1']\n['stained', 'bowl.n.01_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"loading_the_dishwasher\",\n    \"Goal Instructions\": \"Load all plates, bowls, and the mug into the dishwasher.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "locking_every_door_0_Merom_1_int_0_2021-10-20_05-53-14",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ndoor.n.01_1: ['Stained', 'Open', 'Dusty']\ndoor.n.01_2: ['Stained', 'Open', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['open', 'door.n.01_1']\n['open', 'door.n.01_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"locking_every_door\",\n    \"Goal Instructions\": \"Close and lock all the doors.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "locking_every_window_0_Merom_1_int_0_2021-11-01_14-51-10",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nwindow.n.01_1: ['Stained', 'Open', 'Dusty']\nwindow.n.01_2: ['Stained', 'Open', 'Dusty']\nwindow.n.01_3: ['Stained', 'Open', 'Dusty']\nwindow.n.01_4: ['Stained', 'Open', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\nsofa.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['open', 'window.n.01_1']\n['open', 'window.n.01_2']\n['open', 'window.n.01_3']\n['open', 'window.n.01_4']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"locking_every_window\",\n    \"Goal Instructions\": \"Close and lock all the windows.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "making_tea_0_Wainscott_0_int_0_2021-10-26_12-49-48",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nteapot.n.01_1: ['Stained', 'Dusty']\ntea_bag.n.01_1: ['Stained', 'Soaked', 'Dusty']\nlemon.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nknife.n.01_1: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\nstove.n.01_1: ['ToggledOn', 'Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['inside', 'teapot.n.01_1', 'cabinet.n.01_1']\n['inside', 'tea_bag.n.01_1', 'cabinet.n.01_1']\n['inside', 'lemon.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'knife.n.01_1', 'cabinet.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"making_tea\",\n    \"Goal Instructions\": \"Slice the lemon, heat the tea on the stove.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "mopping_floors_0_Benevolence_2_int_0_2021-10-25_21-01-58",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbroom.n.01_1: ['Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\nsoap.n.01_1: []\nbucket.n.01_1: ['Stained', 'Dusty']\npiece_of_cloth.n.01_1: ['Stained', 'Soaked']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'broom.n.01_1', 'floor.n.01_2']\n['onfloor', 'soap.n.01_1', 'floor.n.01_1']\n['onfloor', 'bucket.n.01_1', 'floor.n.01_1']\n['onfloor', 'piece_of_cloth.n.01_1', 'floor.n.01_1']\n['stained', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"mopping_floors\",\n    \"Goal Instructions\": \"Use the bucket, soap and broom to clean the stained floor, when you are done, leave the soap in the bucket and place the bucket and broom next to the sink.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "moving_boxes_to_storage_0_Merom_0_int_0_2021-06-11_20-04-35",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncarton.n.02_1: ['Open', 'Dusty']\ncarton.n.02_2: ['Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\nshelf.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['onfloor', 'carton.n.02_2', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_2']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"moving_boxes_to_storage\",\n    \"Goal Instructions\": \"Move carton1 to floor2 and place carton2 on top of carton1.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "opening_packages_0_Benevolence_2_int_0_2021-10-25_21-06-42",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\npackage.n.02_1: ['Open', 'Dusty']\npackage.n.02_2: ['Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'package.n.02_1', 'floor.n.01_1']\n['onfloor', 'package.n.02_2', 'floor.n.01_1']\n['not', 'open', 'package.n.02_1']\n['not', 'open', 'package.n.02_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"opening_packages\",\n    \"Goal Instructions\": \"Open all packages.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "opening_presents_0_Benevolence_2_int_0_2021-10-25_21-10-48",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\npackage.n.02_1: ['Open', 'Dusty']\npackage.n.02_2: ['Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'package.n.02_1', 'floor.n.01_1']\n['onfloor', 'package.n.02_2', 'floor.n.01_1']\n['not', 'open', 'package.n.02_1']\n['not', 'open', 'package.n.02_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"opening_presents\",\n    \"Goal Instructions\": \"Open all the gift packages.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "organizing_boxes_in_garage_0_Ihlen_0_int_0_2021-08-24_22-59-54",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncarton.n.02_1: ['Open', 'Dusty']\ncarton.n.02_2: ['Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nball.n.01_1: ['Stained', 'Dusty']\nball.n.01_2: ['Stained', 'Dusty']\nplate.n.04_1: ['Stained', 'Dusty']\nplate.n.04_2: ['Stained', 'Dusty']\nplate.n.04_3: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nsaucepan.n.01_1: ['Stained', 'Dusty']\nshelf.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['onfloor', 'carton.n.02_2', 'floor.n.01_1']\n['onfloor', 'ball.n.01_1', 'floor.n.01_1']\n['onfloor', 'ball.n.01_2', 'floor.n.01_1']\n['inside', 'plate.n.04_1', 'shelf.n.01_1']\n['inside', 'plate.n.04_2', 'shelf.n.01_1']\n['inside', 'plate.n.04_3', 'shelf.n.01_1']\n['inside', 'saucepan.n.01_1', 'shelf.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"organizing_boxes_in_garage\",\n    \"Goal Instructions\": \"Put all balls and plates inside separate cartons, put the saucepan inside one of the cartons, and place all cartons on the floor.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "organizing_file_cabinet_0_Pomaria_0_int_0_2021-06-08_15-27-20",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nfloor.n.01_1: ['Stained', 'Dusty']\nmarker.n.03_1: ['Stained', 'Dusty']\nchair.n.01_1: ['Stained', 'Dusty']\ndocument.n.01_1: ['Dusty']\ndocument.n.01_2: ['Dusty']\ndocument.n.01_3: ['Dusty']\ndocument.n.01_4: ['Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nfolder.n.02_1: ['Open', 'Dusty']\nfolder.n.02_2: ['Open', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'marker.n.03_1', 'chair.n.01_1']\n['ontop', 'document.n.01_1', 'table.n.02_1']\n['inside', 'document.n.01_2', 'cabinet.n.01_1']\n['ontop', 'document.n.01_3', 'table.n.02_1']\n['inside', 'document.n.01_4', 'cabinet.n.01_1']\n['ontop', 'folder.n.02_1', 'table.n.02_1']\n['onfloor', 'folder.n.02_2', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"organizing_file_cabinet\",\n    \"Goal Instructions\": \"Place all documents and folders inside the cabinet, and put the marker on the table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "organizing_school_stuff_0_Wainscott_1_int_0_2021-08-24_22-56-24",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nhighlighter.n.02_1: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\npencil.n.01_1: ['Stained', 'Dusty']\npen.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ncalculator.n.02_1: ['ToggledOn', 'Dusty']\nbook.n.02_1: ['Dusty']\nfolder.n.02_1: ['Open', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nbackpack.n.01_1: ['Stained', 'Open', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'highlighter.n.02_1', 'bed.n.01_1']\n['ontop', 'pencil.n.01_1', 'bed.n.01_1']\n['onfloor', 'pen.n.01_1', 'floor.n.01_1']\n['onfloor', 'calculator.n.02_1', 'floor.n.01_1']\n['ontop', 'book.n.02_1', 'bed.n.01_1']\n['ontop', 'folder.n.02_1', 'bed.n.01_1']\n['onfloor', 'backpack.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"organizing_school_stuff\",\n    \"Goal Instructions\": \"Place the folder, highlighter, pencil, pen, and calculator into the backpack, then leave the backpack on the bed.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "packing_adult_s_bags_0_Ihlen_1_int_0_2021-10-26_09-54-15",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbackpack.n.01_1: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\nhanger.n.02_1: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\nmakeup.n.01_1: []\nmakeup.n.01_2: []\njewelry.n.01_1: ['Stained', 'Dusty']\njewelry.n.01_2: ['Stained', 'Dusty']\ntoothbrush.n.01_1: ['Stained', 'Dusty']\nmouse.n.04_1: ['ToggledOn', 'Stained', 'Dusty']\ndoor.n.01_1: ['Stained', 'Open', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'backpack.n.01_1', 'floor.n.01_1']\n['ontop', 'hanger.n.02_1', 'bed.n.01_1']\n['ontop', 'makeup.n.01_1', 'bed.n.01_1']\n['ontop', 'makeup.n.01_2', 'bed.n.01_1']\n['ontop', 'toothbrush.n.01_1', 'bed.n.01_1']\n['onfloor', 'jewelry.n.01_1', 'floor.n.01_1']\n['onfloor', 'jewelry.n.01_2', 'floor.n.01_1']\n['ontop', 'mouse.n.04_1', 'bed.n.01_1']\n['open', 'door.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"packing_adult_s_bags\",\n    \"Goal Instructions\": \"Pack all jewelry, makeup, toothbrush, and mouse inside the backpack, and place the backpack on the second floor.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "packing_bags_or_suitcase_0_Merom_1_int_0_2021-10-26_10-04-07",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbackpack.n.01_1: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ntoothbrush.n.01_1: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\nshampoo.n.01_1: ['Frozen']\nhardback.n.01_1: ['Dusty']\nunderwear.n.01_1: ['Stained']\nunderwear.n.01_2: ['Stained']\ntoothpaste.n.01_1: ['Frozen']\ndoor.n.01_1: ['Stained', 'Open', 'Dusty']\nwindow.n.01_1: ['Stained', 'Open', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'backpack.n.01_1', 'floor.n.01_1']\n['ontop', 'toothbrush.n.01_1', 'bed.n.01_1']\n['ontop', 'shampoo.n.01_1', 'bed.n.01_1']\n['ontop', 'hardback.n.01_1', 'bed.n.01_1']\n['ontop', 'underwear.n.01_1', 'bed.n.01_1']\n['ontop', 'underwear.n.01_2', 'bed.n.01_1']\n['ontop', 'toothpaste.n.01_1', 'bed.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"packing_bags_or_suitcase\",\n    \"Goal Instructions\": \"Pack the backpack with underwear, toothbrush, shampoo, hardback, and toothpaste. Place the backpack on the bed or on the floor.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "packing_boxes_for_household_move_or_trip_0_Ihlen_1_int_0_2021-06-08_19-16-19",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncarton.n.02_1: ['Open', 'Dusty']\ncarton.n.02_2: ['Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nbook.n.02_1: ['Dusty']\nbook.n.02_2: ['Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nsweater.n.01_1: ['Stained', 'Dusty']\nshirt.n.01_1: ['Stained', 'Dusty']\nshirt.n.01_2: ['Stained', 'Dusty']\nplate.n.04_1: ['Stained', 'Dusty']\nplate.n.04_2: ['Stained', 'Dusty']\nplate.n.04_3: ['Stained', 'Dusty']\nplate.n.04_4: ['Stained', 'Dusty']\ndishtowel.n.01_1: ['Stained', 'Soaked']\n\nAll initial states in the scene are:\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['onfloor', 'carton.n.02_2', 'floor.n.01_1']\n['ontop', 'book.n.02_2', 'table.n.02_1']\n['ontop', 'book.n.02_1', 'table.n.02_1']\n['onfloor', 'sweater.n.01_1', 'floor.n.01_1']\n['onfloor', 'shirt.n.01_1', 'floor.n.01_1']\n['onfloor', 'shirt.n.01_2', 'floor.n.01_1']\n['ontop', 'plate.n.04_1', 'table.n.02_1']\n['onfloor', 'plate.n.04_2', 'floor.n.01_1']\n['onfloor', 'plate.n.04_3', 'floor.n.01_1']\n['onfloor', 'plate.n.04_4', 'floor.n.01_1']\n['onfloor', 'dishtowel.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"packing_boxes_for_household_move_or_trip\",\n    \"Goal Instructions\": \"Pack all plates, the dishtowel, books, shirts, and the sweater inside separate cartons.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "packing_car_for_trip_0_Ihlen_0_int_0_2021-10-26_10-27-23",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncar.n.01_1: ['Stained', 'Open', 'Dusty']\nbriefcase.n.01_1: ['Stained', 'Open', 'Dusty']\npencil_box.n.01_1: ['Stained', 'Dusty']\nheadset.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nduffel_bag.n.01_1: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'car.n.01_1', 'floor.n.01_1']\n['onfloor', 'briefcase.n.01_1', 'floor.n.01_2']\n['ontop', 'pencil_box.n.01_1', 'table.n.02_1']\n['ontop', 'headset.n.01_1', 'table.n.02_1']\n['onfloor', 'duffel_bag.n.01_1', 'floor.n.01_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"packing_car_for_trip\",\n    \"Goal Instructions\": \"Pack the briefcase, pencil box, headset, and duffel bag inside the car for the trip.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "packing_child_s_bag_0_Beechwood_1_int_0_2021-10-26_10-33-11",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbackpack.n.01_1: ['Stained', 'Open', 'Dusty']\nnotebook.n.01_1: ['Dusty']\nbracelet.n.02_1: ['Stained', 'Dusty']\napple.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nfloor.n.01_1: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\nearphone.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nsunglass.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'backpack.n.01_1', 'floor.n.01_1']\n['ontop', 'sunglass.n.01_1', 'bed.n.01_1']\n['ontop', 'bracelet.n.02_1', 'bed.n.01_1']\n['onfloor', 'notebook.n.01_1', 'floor.n.01_1']\n['ontop', 'apple.n.01_1', 'bed.n.01_1']\n['ontop', 'earphone.n.01_1', 'bed.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"packing_child_s_bag\",\n    \"Goal Instructions\": \"Place the sunglasses, notebook, bracelet, apple, and earphones inside the backpack next to the bed.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "packing_food_for_work_0_Ihlen_1_int_0_2021-06-08_19-36-15",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncarton.n.02_1: ['Open', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\nsandwich.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\napple.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nsnack_food.n.01_1: ['Frozen', 'Cooked', 'Burnt']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\njuice.n.01_1: ['Frozen']\nfloor.n.01_1: ['Stained', 'Dusty']\ndoor.n.01_1: ['Stained', 'Open', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['inside', 'sandwich.n.01_1', 'electric_refrigerator.n.01_1']\n['ontop', 'apple.n.01_1', 'countertop.n.01_1']\n['inside', 'snack_food.n.01_1', 'cabinet.n.01_1']\n['ontop', 'juice.n.01_1', 'countertop.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"packing_food_for_work\",\n    \"Goal Instructions\": \"Pack a sandwich, an apple, a snack food, and a juice into a carton, and place the carton on the floor or on the countertop.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "packing_lunches_0_Beechwood_0_int_0_2021-10-26_11-03-14",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nsalad.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\nsandwich.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nchip.n.04_1: ['Cooked', 'Burnt']\nchip.n.04_2: ['Cooked', 'Burnt']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\njuice.n.01_1: ['Frozen']\ntable.n.02_1: ['Stained', 'Dusty']\npop.n.02_1: ['Frozen']\napple.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\ncountertop.n.01_1: ['Stained', 'Dusty']\nbanana.n.02_1: ['Stained', 'Frozen', 'Dusty', 'Cooked', 'Burnt']\ncarton.n.02_1: ['Open', 'Dusty']\ncarton.n.02_2: ['Open', 'Dusty']\ncookie.n.01_1: ['Frozen', 'Cooked', 'Burnt']\ncookie.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['inside', 'salad.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'sandwich.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'chip.n.04_1', 'cabinet.n.01_1']\n['inside', 'chip.n.04_2', 'cabinet.n.01_1']\n['ontop', 'juice.n.01_1', 'table.n.02_1']\n['ontop', 'pop.n.02_1', 'table.n.02_1']\n['ontop', 'apple.n.01_1', 'countertop.n.01_1']\n['ontop', 'banana.n.02_1', 'countertop.n.01_1']\n['onfloor', 'carton.n.02_1', 'floor.n.01_2']\n['onfloor', 'carton.n.02_2', 'floor.n.01_2']\n['ontop', 'cookie.n.01_1', 'countertop.n.01_1']\n['ontop', 'cookie.n.01_2', 'countertop.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"packing_lunches\",\n    \"Goal Instructions\": \"Place chips, cookies, salad, juice, sandwich, and pop in separate cartons, ensuring the correct items are inside each carton. Additionally, put either an apple or a banana in each of carton1 and carton2.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "packing_picnics_0_Wainscott_0_int_0_2021-10-26_11-07-29",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncarton.n.02_1: ['Open', 'Dusty']\ncarton.n.02_2: ['Open', 'Dusty']\ncarton.n.02_3: ['Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\nchip.n.04_1: ['Cooked', 'Burnt']\nchip.n.04_2: ['Cooked', 'Burnt']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nsandwich.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nsandwich.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nsandwich.n.01_3: ['Frozen', 'Cooked', 'Burnt']\nsandwich.n.01_4: ['Frozen', 'Cooked', 'Burnt']\ncountertop.n.01_1: ['Stained', 'Dusty']\nmelon.n.01_1: ['Stained', 'Frozen', 'Cooked', 'Burnt']\nstrawberry.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nstrawberry.n.01_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nstrawberry.n.01_3: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nstrawberry.n.01_4: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\ngrape.n.01_1: ['Frozen', 'Cooked', 'Burnt']\ngrape.n.01_2: ['Frozen', 'Cooked', 'Burnt']\ngrape.n.01_3: ['Frozen', 'Cooked', 'Burnt']\ngrape.n.01_4: ['Frozen', 'Cooked', 'Burnt']\npeach.n.03_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\npeach.n.03_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\npop.n.02_1: ['Frozen']\npop.n.02_2: ['Frozen']\nbeer.n.01_1: ['Frozen']\nbeer.n.01_2: ['Frozen']\nwater.n.06_1: ['Frozen']\nwater.n.06_2: ['Frozen']\nwater.n.06_3: ['Frozen']\nwater.n.06_4: ['Frozen']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['onfloor', 'carton.n.02_2', 'floor.n.01_2']\n['onfloor', 'carton.n.02_3', 'floor.n.01_2']\n['inside', 'chip.n.04_1', 'cabinet.n.01_1']\n['inside', 'chip.n.04_2', 'cabinet.n.01_1']\n['ontop', 'sandwich.n.01_1', 'countertop.n.01_1']\n['ontop', 'sandwich.n.01_2', 'countertop.n.01_1']\n['ontop', 'sandwich.n.01_3', 'countertop.n.01_1']\n['ontop', 'sandwich.n.01_4', 'countertop.n.01_1']\n['ontop', 'melon.n.01_1', 'countertop.n.01_1']\n['inside', 'strawberry.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'strawberry.n.01_2', 'electric_refrigerator.n.01_1']\n['inside', 'strawberry.n.01_3', 'electric_refrigerator.n.01_1']\n['inside', 'strawberry.n.01_4', 'electric_refrigerator.n.01_1']\n['inside', 'grape.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'grape.n.01_2', 'electric_refrigerator.n.01_1']\n['inside', 'grape.n.01_3', 'electric_refrigerator.n.01_1']\n['inside', 'grape.n.01_4', 'electric_refrigerator.n.01_1']\n['inside', 'peach.n.03_1', 'electric_refrigerator.n.01_1']\n['inside', 'peach.n.03_2', 'electric_refrigerator.n.01_1']\n['inside', 'pop.n.02_1', 'electric_refrigerator.n.01_1']\n['inside', 'pop.n.02_2', 'electric_refrigerator.n.01_1']\n['inside', 'beer.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'beer.n.01_2', 'electric_refrigerator.n.01_1']\n['inside', 'water.n.06_1', 'cabinet.n.01_1']\n['inside', 'water.n.06_2', 'cabinet.n.01_1']\n['inside', 'water.n.06_3', 'cabinet.n.01_1']\n['inside', 'water.n.06_4', 'cabinet.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"packing_picnics\",\n    \"Goal Instructions\": \"Pack all chips and sandwiches inside one carton. Pack all fruits inside one carton. Pack all drinks inside one carton.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "picking_up_take-out_food_0_Ihlen_1_int_0_2021-06-10_22-09-43",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nfloor.n.01_1: ['Stained', 'Dusty']\ncarton.n.02_1: ['Open', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nsushi.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nhamburger.n.01_1: ['Frozen', 'Cooked', 'Burnt']\n\nAll initial states in the scene are:\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['inside', 'sushi.n.01_1', 'carton.n.02_1']\n['inside', 'hamburger.n.01_1', 'carton.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"picking_up_take-out_food\",\n    \"Goal Instructions\": \"Place the sushi and hamburger inside separate cartons that are on the table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "picking_up_trash_0_Beechwood_0_int_1_2021-10-26_14-06-49",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nashcan.n.01_1: ['Stained', 'Dusty']\npad.n.01_1: []\npad.n.01_2: []\npad.n.01_3: []\npop.n.02_1: ['Frozen']\npop.n.02_2: ['Frozen']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'ashcan.n.01_1', 'floor.n.01_2']\n['onfloor', 'pad.n.01_1', 'floor.n.01_2']\n['onfloor', 'pad.n.01_2', 'floor.n.01_2']\n['onfloor', 'pad.n.01_3', 'floor.n.01_1']\n['onfloor', 'pop.n.02_1', 'floor.n.01_1']\n['onfloor', 'pop.n.02_2', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_2']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"picking_up_trash\",\n    \"Goal Instructions\": \"Pick up all pads and pops and put them inside the ashcan.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "polishing_furniture_0_Ihlen_0_int_0_2021-10-26_11-35-40",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nshelf.n.01_1: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['dusty', 'shelf.n.01_1']\n['dusty', 'table.n.02_1']\n['ontop', 'rag.n.01_1', 'table.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"polishing_furniture\",\n    \"Goal Instructions\": \"Polish the table and the shelf, and place the rag under the table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "polishing_shoes_0_Wainscott_0_int_0_2021-06-10_21-28-31",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nshoe.n.01_1: ['Stained', 'Dusty']\nshoe.n.01_2: ['Stained', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\nfloor.n.01_1: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['stained', 'shoe.n.01_1']\n['stained', 'shoe.n.01_2']\n['onfloor', 'rag.n.01_1', 'floor.n.01_1']\n['not', 'soaked', 'rag.n.01_1']\n['onfloor', 'shoe.n.01_1', 'floor.n.01_1']\n['onfloor', 'shoe.n.01_2', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"polishing_shoes\",\n    \"Goal Instructions\": \"Soak the rag, polish both shoes, and place the rag next to the sink.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "polishing_silver_0_Merom_1_int_0_2021-10-26_11-43-15",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nspoon.n.01_1: ['Stained', 'Dusty']\nspoon.n.01_2: ['Stained', 'Dusty']\nspoon.n.01_3: ['Stained', 'Dusty']\nspoon.n.01_4: ['Stained', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['dusty', 'spoon.n.01_1']\n['dusty', 'spoon.n.01_2']\n['dusty', 'spoon.n.01_3']\n['dusty', 'spoon.n.01_4']\n['inside', 'rag.n.01_1', 'cabinet.n.01_1']\n['inside', 'spoon.n.01_1', 'cabinet.n.01_1']\n['inside', 'spoon.n.01_2', 'cabinet.n.01_1']\n['inside', 'spoon.n.01_3', 'cabinet.n.01_1']\n['inside', 'spoon.n.01_4', 'cabinet.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"polishing_silver\",\n    \"Goal Instructions\": \"Polish all spoons and put them inside the cabinet.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "preparing_a_shower_for_child_0_Ihlen_0_int_0_2021-10-25_21-36-25",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nshampoo.n.01_1: ['Frozen']\nfloor.n.01_1: ['Stained', 'Dusty']\nsoap.n.01_1: []\ntowel.n.01_1: ['Stained', 'Soaked']\nshower.n.01_1: ['Stained']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'shampoo.n.01_1', 'floor.n.01_1']\n['onfloor', 'soap.n.01_1', 'floor.n.01_1']\n['onfloor', 'towel.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"preparing_a_shower_for_child\",\n    \"Goal Instructions\": \"Place the towel, shampoo, and soap on the floor near the sink for the child's shower.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "preparing_salad_0_Pomaria_1_int_1_2021-10-26_14-17-24",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\nlettuce.n.03_1: ['Frozen']\nlettuce.n.03_2: ['Frozen']\ncountertop.n.01_1: ['Stained', 'Dusty']\napple.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\napple.n.01_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\ntomato.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\ntomato.n.01_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nradish.n.01_1: ['Stained', 'Frozen', 'Cooked', 'Burnt']\nradish.n.01_2: ['Stained', 'Frozen', 'Cooked', 'Burnt']\ncarving_knife.n.01_1: ['Stained', 'Dusty']\nplate.n.04_1: ['Stained', 'Dusty']\nplate.n.04_2: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'lettuce.n.03_1', 'countertop.n.01_1']\n['ontop', 'lettuce.n.03_2', 'countertop.n.01_1']\n['ontop', 'apple.n.01_1', 'countertop.n.01_1']\n['ontop', 'apple.n.01_2', 'countertop.n.01_1']\n['inside', 'tomato.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'tomato.n.01_2', 'electric_refrigerator.n.01_1']\n['ontop', 'radish.n.01_1', 'countertop.n.01_1']\n['ontop', 'radish.n.01_2', 'countertop.n.01_1']\n['inside', 'plate.n.04_1', 'cabinet.n.01_1']\n['not', 'dusty', 'plate.n.04_1']\n['inside', 'plate.n.04_2', 'cabinet.n.01_1']\n['not', 'dusty', 'plate.n.04_2']\n['inside', 'carving_knife.n.01_1', 'cabinet.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"preparing_salad\",\n    \"Goal Instructions\": \"Place a whole lettuce, a sliced apple, a sliced tomato, and a whole radish on separate plates.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "preserving_food_0_Rs_int_0_2021-08-25_15-53-33",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nstrawberry.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nstrawberry.n.01_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\nbeef.n.02_1: ['Frozen', 'Cooked', 'Burnt']\njar.n.01_1: ['Stained', 'Open', 'Dusty']\npan.n.01_1: ['Stained', 'Dusty']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\ncarving_knife.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'strawberry.n.01_1', 'countertop.n.01_1']\n['ontop', 'strawberry.n.01_2', 'countertop.n.01_1']\n['ontop', 'beef.n.02_1', 'countertop.n.01_1']\n['ontop', 'jar.n.01_1', 'countertop.n.01_1']\n['open', 'jar.n.01_1']\n['ontop', 'pan.n.01_1', 'countertop.n.01_1']\n['ontop', 'carving_knife.n.01_1', 'countertop.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"preserving_food\",\n    \"Goal Instructions\": \"Slice and cook all the strawberries, then seal them inside the jar, remember to freeze the beef.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "putting_away_Christmas_decorations_0_Wainscott_0_int_0_2021-06-06_17-03-25",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nwreath.n.01_1: ['Dusty']\nwreath.n.01_2: ['Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nbow.n.08_1: ['Dusty']\nbow.n.08_2: ['Dusty']\nbow.n.08_3: ['Dusty']\nribbon.n.01_1: ['Stained', 'Dusty']\nribbon.n.01_2: ['Stained', 'Dusty']\nribbon.n.01_3: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'wreath.n.01_1', 'floor.n.01_1']\n['onfloor', 'wreath.n.01_2', 'floor.n.01_1']\n['onfloor', 'bow.n.08_1', 'floor.n.01_1']\n['onfloor', 'bow.n.08_2', 'floor.n.01_1']\n['onfloor', 'bow.n.08_3', 'floor.n.01_1']\n['onfloor', 'ribbon.n.01_1', 'floor.n.01_1']\n['onfloor', 'ribbon.n.01_2', 'floor.n.01_1']\n['onfloor', 'ribbon.n.01_3', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"putting_away_Christmas_decorations\",\n    \"Goal Instructions\": \"Place all wreaths and bows next to the cabinet, and put all ribbons inside the cabinet.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "putting_away_Halloween_decorations_0_Rs_int_0_2021-10-25_22-42-17",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\npumpkin.n.02_1: ['Frozen', 'Cooked', 'Burnt']\npumpkin.n.02_2: ['Frozen', 'Cooked', 'Burnt']\nfloor.n.01_1: ['Stained', 'Dusty']\ncaldron.n.01_1: ['Stained', 'Dusty']\nsheet.n.03_1: ['Stained']\ntable.n.02_1: ['Stained', 'Dusty']\ncandle.n.01_1: ['Dusty']\ncandle.n.01_2: ['Dusty']\ncandle.n.01_3: ['Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nsofa.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'pumpkin.n.02_1', 'floor.n.01_1']\n['onfloor', 'pumpkin.n.02_2', 'floor.n.01_1']\n['onfloor', 'caldron.n.01_1', 'floor.n.01_1']\n['ontop', 'sheet.n.03_1', 'table.n.02_1']\n['onfloor', 'candle.n.01_1', 'floor.n.01_1']\n['onfloor', 'candle.n.01_2', 'floor.n.01_1']\n['onfloor', 'candle.n.01_3', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"putting_away_Halloween_decorations\",\n    \"Goal Instructions\": \"Place all pumpkins and candles into the cabinet, arrange the sheet either next to or on the table, and position the caldron next to the table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "putting_away_toys_0_Ihlen_0_int_0_2021-10-25_22-47-44",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nplaything.n.01_1: ['Stained', 'Dusty']\nplaything.n.01_2: ['Stained', 'Dusty']\nplaything.n.01_3: ['Stained', 'Dusty']\nplaything.n.01_4: ['Stained', 'Dusty']\nplaything.n.01_5: ['Stained', 'Dusty']\nplaything.n.01_6: ['Stained', 'Dusty']\nplaything.n.01_7: ['Stained', 'Dusty']\nplaything.n.01_8: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\ncarton.n.02_1: ['Open', 'Dusty']\ncarton.n.02_2: ['Open', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'plaything.n.01_1', 'floor.n.01_1']\n['onfloor', 'plaything.n.01_2', 'floor.n.01_1']\n['onfloor', 'plaything.n.01_3', 'floor.n.01_1']\n['onfloor', 'plaything.n.01_4', 'floor.n.01_1']\n['onfloor', 'plaything.n.01_5', 'floor.n.01_2']\n['onfloor', 'plaything.n.01_6', 'floor.n.01_2']\n['onfloor', 'plaything.n.01_7', 'floor.n.01_2']\n['onfloor', 'plaything.n.01_8', 'floor.n.01_2']\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['ontop', 'carton.n.02_2', 'table.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"putting_away_toys\",\n    \"Goal Instructions\": \"Put all the toys into cartons.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "putting_dishes_away_after_cleaning_0_Ihlen_1_int_0_2021-10-25_22-54-09",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nplate.n.04_1: ['Stained', 'Dusty']\nplate.n.04_2: ['Stained', 'Dusty']\nplate.n.04_3: ['Stained', 'Dusty']\nplate.n.04_4: ['Stained', 'Dusty']\nplate.n.04_5: ['Stained', 'Dusty']\nplate.n.04_6: ['Stained', 'Dusty']\nplate.n.04_7: ['Stained', 'Dusty']\nplate.n.04_8: ['Stained', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\ncountertop.n.01_2: ['Stained', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'plate.n.04_1', 'countertop.n.01_1']\n['ontop', 'plate.n.04_2', 'countertop.n.01_1']\n['ontop', 'plate.n.04_3', 'countertop.n.01_1']\n['ontop', 'plate.n.04_4', 'countertop.n.01_1']\n['ontop', 'plate.n.04_5', 'countertop.n.01_2']\n['ontop', 'plate.n.04_6', 'countertop.n.01_2']\n['ontop', 'plate.n.04_7', 'countertop.n.01_2']\n['ontop', 'plate.n.04_8', 'countertop.n.01_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"putting_dishes_away_after_cleaning\",\n    \"Goal Instructions\": \"Put all plates inside the cabinet after cleaning.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "putting_leftovers_away_0_Ihlen_1_int_0_2021-06-08_13-42-57",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\npasta.n.02_1: ['Cooked', 'Burnt']\npasta.n.02_2: ['Cooked', 'Burnt']\npasta.n.02_3: ['Cooked', 'Burnt']\npasta.n.02_4: ['Cooked', 'Burnt']\nfloor.n.01_1: ['Stained', 'Dusty']\nsauce.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nsauce.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nsauce.n.01_3: ['Frozen', 'Cooked', 'Burnt']\nsauce.n.01_4: ['Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'pasta.n.02_1', 'countertop.n.01_1']\n['ontop', 'pasta.n.02_2', 'countertop.n.01_1']\n['ontop', 'pasta.n.02_3', 'countertop.n.01_1']\n['ontop', 'pasta.n.02_4', 'countertop.n.01_1']\n['ontop', 'sauce.n.01_1', 'countertop.n.01_1']\n['ontop', 'sauce.n.01_2', 'countertop.n.01_1']\n['ontop', 'sauce.n.01_3', 'countertop.n.01_1']\n['ontop', 'sauce.n.01_4', 'countertop.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"putting_leftovers_away\",\n    \"Goal Instructions\": \"Put all pasta and sauce inside the fridge.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "putting_up_Christmas_decorations_inside_0_Ihlen_1_int_0_2021-06-03_14-27-09",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nchristmas_tree.n.05_1: []\nwreath.n.01_1: ['Dusty']\nbow.n.08_1: ['Dusty']\nbow.n.08_2: ['Dusty']\nbow.n.08_3: ['Dusty']\ncandle.n.01_1: ['Dusty']\ncandle.n.01_2: ['Dusty']\nwrapping.n.01_1: []\nwrapping.n.01_2: []\nwrapping.n.01_3: []\ncarton.n.02_1: ['Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nsofa.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'christmas_tree.n.05_1', 'floor.n.01_1']\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['inside', 'wreath.n.01_1', 'carton.n.02_1']\n['inside', 'bow.n.08_1', 'carton.n.02_1']\n['inside', 'bow.n.08_2', 'carton.n.02_1']\n['inside', 'bow.n.08_3', 'carton.n.02_1']\n['inside', 'candle.n.01_1', 'carton.n.02_1']\n['inside', 'candle.n.01_2', 'carton.n.02_1']\n['onfloor', 'wrapping.n.01_1', 'floor.n.01_1']\n['onfloor', 'wrapping.n.01_2', 'floor.n.01_1']\n['onfloor', 'wrapping.n.01_3', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"putting_up_Christmas_decorations_inside\",\n    \"Goal Instructions\": \"Place all wrappings under or next to the Christmas tree, place all candles on the table, place one bow on the table, two bows on the sofa, and place the wreath on the table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "re-shelving_library_books_0_Rs_int_0_2021-10-25_21-22-26",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbook.n.02_1: ['Dusty']\nbook.n.02_2: ['Dusty']\nbook.n.02_3: ['Dusty']\nbook.n.02_4: ['Dusty']\nbook.n.02_5: ['Dusty']\nbook.n.02_6: ['Dusty']\nbook.n.02_7: ['Dusty']\nbook.n.02_8: ['Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nshelf.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'book.n.02_1', 'table.n.02_1']\n['ontop', 'book.n.02_2', 'table.n.02_1']\n['ontop', 'book.n.02_3', 'table.n.02_1']\n['ontop', 'book.n.02_4', 'table.n.02_1']\n['ontop', 'book.n.02_5', 'table.n.02_1']\n['ontop', 'book.n.02_6', 'table.n.02_1']\n['ontop', 'book.n.02_7', 'table.n.02_1']\n['ontop', 'book.n.02_8', 'table.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"re-shelving_library_books\",\n    \"Goal Instructions\": \"Place books 1 through 4 on the shelf, and place books 5 through 8 on the table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "rearranging_furniture_0_Pomaria_2_int_1_2021-06-22_16-39-21",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nlamp.n.02_1: ['ToggledOn', 'Dusty']\nlamp.n.02_2: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nseat.n.03_1: ['Stained', 'Dusty']\nseat.n.03_2: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\nwindow.n.01_1: ['Stained', 'Open', 'Dusty']\ndoor.n.01_1: ['Stained', 'Open', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'lamp.n.02_1', 'floor.n.01_1']\n['onfloor', 'lamp.n.02_2', 'floor.n.01_1']\n['onfloor', 'seat.n.03_1', 'floor.n.01_1']\n['ontop', 'seat.n.03_2', 'bed.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"rearranging_furniture\",\n    \"Goal Instructions\": \"Place lamp1 next to the door, lamp2 next to the window, have seat1 touching the bed, and place seat2 next to the window.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "serving_a_meal_0_Merom_1_int_0_2021-10-26_00-34-17",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nchicken.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nchicken.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nknife.n.01_1: ['Stained', 'Dusty']\nknife.n.01_2: ['Stained', 'Dusty']\nfork.n.01_1: ['Stained', 'Dusty']\nfork.n.01_2: ['Stained', 'Dusty']\nspoon.n.01_1: ['Stained', 'Dusty']\nspoon.n.01_2: ['Stained', 'Dusty']\nplate.n.04_1: ['Stained', 'Dusty']\nplate.n.04_2: ['Stained', 'Dusty']\nsoup.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nsoup.n.01_2: ['Frozen', 'Cooked', 'Burnt']\ntable.n.02_1: ['Stained', 'Dusty']\nbread.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nbread.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\nsalad.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nsalad.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nwater.n.06_1: ['Frozen']\nwater.n.06_2: ['Frozen']\ncake.n.03_1: ['Frozen', 'Cooked', 'Burnt']\ncake.n.03_2: ['Frozen', 'Cooked', 'Burnt']\nstove.n.01_1: ['ToggledOn', 'Stained', 'Open', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_2: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['cooked', 'chicken.n.01_1']\n['cooked', 'chicken.n.01_2']\n['inside', 'knife.n.01_1', 'cabinet.n.01_1']\n['inside', 'knife.n.01_2', 'cabinet.n.01_1']\n['inside', 'fork.n.01_1', 'cabinet.n.01_1']\n['inside', 'fork.n.01_2', 'cabinet.n.01_1']\n['inside', 'spoon.n.01_1', 'cabinet.n.01_1']\n['inside', 'spoon.n.01_2', 'cabinet.n.01_1']\n['inside', 'plate.n.04_1', 'cabinet.n.01_2']\n['inside', 'plate.n.04_2', 'cabinet.n.01_1']\n['ontop', 'soup.n.01_1', 'table.n.02_1']\n['ontop', 'soup.n.01_2', 'table.n.02_1']\n['inside', 'bread.n.01_2', 'electric_refrigerator.n.01_1']\n['inside', 'bread.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'salad.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'salad.n.01_2', 'electric_refrigerator.n.01_1']\n['inside', 'chicken.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'chicken.n.01_2', 'electric_refrigerator.n.01_1']\n['inside', 'water.n.06_1', 'electric_refrigerator.n.01_1']\n['inside', 'water.n.06_2', 'electric_refrigerator.n.01_1']\n['inside', 'cake.n.03_1', 'electric_refrigerator.n.01_1']\n['inside', 'cake.n.03_2', 'electric_refrigerator.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"serving_a_meal\",\n    \"Goal Instructions\": \"Serve the meal by placing all food and drinks on the table along with the appropriate utensils.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "serving_hors_d_oeuvres_0_Wainscott_0_int_0_2021-10-26_14-00-22",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nsalad.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nsalad.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nsalad.n.01_3: ['Frozen', 'Cooked', 'Burnt']\nsalad.n.01_4: ['Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\ntray.n.01_1: ['Stained', 'Dusty']\nparsley.n.02_1: ['Frozen', 'Cooked', 'Burnt']\nparsley.n.02_2: ['Frozen', 'Cooked', 'Burnt']\nparsley.n.02_3: ['Frozen', 'Cooked', 'Burnt']\nparsley.n.02_4: ['Frozen', 'Cooked', 'Burnt']\ncracker.n.01_1: ['Frozen', 'Cooked', 'Burnt']\ncracker.n.01_2: ['Frozen', 'Cooked', 'Burnt']\ncracker.n.01_3: ['Frozen', 'Cooked', 'Burnt']\ncracker.n.01_4: ['Frozen', 'Cooked', 'Burnt']\ntable.n.02_1: ['Stained', 'Dusty']\ncheese.n.01_1: ['Frozen', 'Cooked', 'Burnt']\ncheese.n.01_2: ['Frozen', 'Cooked', 'Burnt']\ncheese.n.01_3: ['Frozen', 'Cooked', 'Burnt']\ncheese.n.01_4: ['Frozen', 'Cooked', 'Burnt']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['inside', 'salad.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'salad.n.01_2', 'electric_refrigerator.n.01_1']\n['inside', 'salad.n.01_3', 'electric_refrigerator.n.01_1']\n['inside', 'salad.n.01_4', 'electric_refrigerator.n.01_1']\n['inside', 'parsley.n.02_1', 'electric_refrigerator.n.01_1']\n['inside', 'parsley.n.02_2', 'electric_refrigerator.n.01_1']\n['inside', 'parsley.n.02_3', 'electric_refrigerator.n.01_1']\n['inside', 'parsley.n.02_4', 'electric_refrigerator.n.01_1']\n['onfloor', 'tray.n.01_1', 'floor.n.01_1']\n['ontop', 'cracker.n.01_1', 'table.n.02_1']\n['ontop', 'cracker.n.01_2', 'table.n.02_1']\n['ontop', 'cracker.n.01_3', 'table.n.02_1']\n['ontop', 'cracker.n.01_4', 'table.n.02_1']\n['inside', 'cheese.n.01_1', 'electric_refrigerator.n.01_1']\n['inside', 'cheese.n.01_2', 'electric_refrigerator.n.01_1']\n['inside', 'cheese.n.01_3', 'electric_refrigerator.n.01_1']\n['inside', 'cheese.n.01_4', 'electric_refrigerator.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"serving_hors_d_oeuvres\",\n    \"Goal Instructions\": \"Place the tray on the table, put the crackers on the table, place the salads next to the crackers, and put the parsley on top of the cheese.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "setting_mousetraps_0_Beechwood_1_int_0_2021-10-26_13-53-26",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nmousetrap.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nmousetrap.n.01_2: ['ToggledOn', 'Stained', 'Dusty']\nmousetrap.n.01_3: ['ToggledOn', 'Stained', 'Dusty']\nmousetrap.n.01_4: ['ToggledOn', 'Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\ntoilet.n.02_1: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'mousetrap.n.01_1', 'bed.n.01_1']\n['ontop', 'mousetrap.n.01_2', 'bed.n.01_1']\n['ontop', 'mousetrap.n.01_3', 'bed.n.01_1']\n['ontop', 'mousetrap.n.01_4', 'bed.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_2']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"setting_mousetraps\",\n    \"Goal Instructions\": \"Place mousetraps 1 and 2 on the floor, and mousetraps 3 and 4 next to the toilet.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "setting_up_candles_0_Wainscott_0_int_0_2021-10-26_13-40-51",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncandle.n.01_1: ['Dusty']\ncandle.n.01_2: ['Dusty']\ncandle.n.01_3: ['Dusty']\ncandle.n.01_4: ['Dusty']\ncandle.n.01_5: ['Dusty']\ncandle.n.01_6: ['Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\ntable.n.02_2: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\ncarton.n.02_1: ['Open', 'Dusty']\ncarton.n.02_2: ['Open', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['onfloor', 'carton.n.02_2', 'floor.n.01_1']\n['inside', 'candle.n.01_1', 'carton.n.02_1']\n['inside', 'candle.n.01_2', 'carton.n.02_1']\n['inside', 'candle.n.01_3', 'carton.n.02_1']\n['inside', 'candle.n.01_4', 'carton.n.02_2']\n['inside', 'candle.n.01_5', 'carton.n.02_2']\n['inside', 'candle.n.01_6', 'carton.n.02_2']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"setting_up_candles\",\n    \"Goal Instructions\": \"Place 3 candles on each table.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "sorting_books_0_Pomaria_1_int_0_2021-10-26_13-27-18",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nhardback.n.01_1: ['Dusty']\nhardback.n.01_2: ['Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nshelf.n.01_1: ['Stained', 'Dusty']\nbook.n.02_1: ['Dusty']\nbook.n.02_2: ['Dusty']\n\nAll initial states in the scene are:\n['ontop', 'hardback.n.01_1', 'table.n.02_1']\n['onfloor', 'hardback.n.01_2', 'floor.n.01_1']\n['onfloor', 'book.n.02_1', 'floor.n.01_1']\n['ontop', 'book.n.02_2', 'table.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"sorting_books\",\n    \"Goal Instructions\": \"Place all types of books on the shelf.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "sorting_groceries_0_Wainscott_0_int_0_2021-10-26_13-36-01",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbread.n.01_1: ['Frozen', 'Cooked', 'Burnt']\ncountertop.n.01_1: ['Stained', 'Dusty']\nflour.n.01_1: []\nfloor.n.01_1: ['Stained', 'Dusty']\nmilk.n.01_1: ['Frozen', 'Cooked']\nchair.n.01_1: ['Stained', 'Dusty']\nmeat.n.01_1: ['Frozen', 'Cooked', 'Burnt']\ntable.n.02_1: ['Stained', 'Dusty']\ncheese.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nyogurt.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nsoup.n.01_1: ['Frozen', 'Cooked', 'Burnt']\ncarrot.n.03_1: ['Stained', 'Frozen', 'Dusty', 'Cooked', 'Burnt']\ncarrot.n.03_2: ['Stained', 'Frozen', 'Dusty', 'Cooked', 'Burnt']\ncarrot.n.03_3: ['Stained', 'Frozen', 'Dusty', 'Cooked', 'Burnt']\nbroccoli.n.02_1: ['Frozen', 'Cooked', 'Burnt']\napple.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\napple.n.01_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\norange.n.01_1: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\norange.n.01_2: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\norange.n.01_3: ['Sliced', 'Frozen', 'Cooked', 'Burnt']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'bread.n.01_1', 'countertop.n.01_1']\n['onfloor', 'flour.n.01_1', 'floor.n.01_1']\n['ontop', 'milk.n.01_1', 'chair.n.01_1']\n['ontop', 'meat.n.01_1', 'table.n.02_1']\n['ontop', 'cheese.n.01_1', 'table.n.02_1']\n['ontop', 'yogurt.n.01_1', 'table.n.02_1']\n['ontop', 'soup.n.01_1', 'table.n.02_1']\n['ontop', 'carrot.n.03_1', 'countertop.n.01_1']\n['ontop', 'carrot.n.03_2', 'countertop.n.01_1']\n['ontop', 'carrot.n.03_3', 'countertop.n.01_1']\n['ontop', 'broccoli.n.02_1', 'countertop.n.01_1']\n['ontop', 'apple.n.01_1', 'countertop.n.01_1']\n['ontop', 'apple.n.01_2', 'countertop.n.01_1']\n['ontop', 'orange.n.01_1', 'table.n.02_1']\n['ontop', 'orange.n.01_2', 'table.n.02_1']\n['ontop', 'orange.n.01_3', 'table.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"sorting_groceries\",\n    \"Goal Instructions\": \"Sort the groceries into the fridge and the cabinet based on your common sense. Place groceries of the same type next to each other.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "sorting_mail_0_Wainscott_0_int_1_2021-10-26_14-38-16",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nenvelope.n.01_1: []\nenvelope.n.01_2: []\nenvelope.n.01_3: []\nenvelope.n.01_4: []\nfloor.n.01_1: ['Stained', 'Dusty']\nsofa.n.01_1: ['Stained', 'Dusty']\nnewspaper.n.03_1: ['Dusty']\nnewspaper.n.03_2: ['Dusty']\nnewspaper.n.03_3: ['Dusty']\nnewspaper.n.03_4: ['Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'envelope.n.01_1', 'floor.n.01_1']\n['onfloor', 'envelope.n.01_2', 'floor.n.01_1']\n['onfloor', 'envelope.n.01_3', 'floor.n.01_1']\n['onfloor', 'envelope.n.01_4', 'floor.n.01_1']\n['onfloor', 'newspaper.n.03_1', 'floor.n.01_1']\n['onfloor', 'newspaper.n.03_2', 'floor.n.01_1']\n['onfloor', 'newspaper.n.03_3', 'floor.n.01_1']\n['onfloor', 'newspaper.n.03_4', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"sorting_mail\",\n    \"Goal Instructions\": \"Sort the envelopes and newspapers into two stacked piles.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "storing_food_0_Rs_int_0_2021-10-25_21-27-36",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\noatmeal.n.01_1: ['Frozen', 'Cooked', 'Burnt']\noatmeal.n.01_2: ['Frozen', 'Cooked', 'Burnt']\ncountertop.n.01_1: ['Stained', 'Dusty']\nchip.n.04_1: ['Cooked', 'Burnt']\nchip.n.04_2: ['Cooked', 'Burnt']\nvegetable_oil.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nvegetable_oil.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nsugar.n.01_1: ['Cooked']\nsugar.n.01_2: ['Cooked']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'oatmeal.n.01_1', 'countertop.n.01_1']\n['ontop', 'oatmeal.n.01_2', 'countertop.n.01_1']\n['ontop', 'chip.n.04_1', 'countertop.n.01_1']\n['ontop', 'chip.n.04_2', 'countertop.n.01_1']\n['ontop', 'vegetable_oil.n.01_1', 'countertop.n.01_1']\n['ontop', 'vegetable_oil.n.01_2', 'countertop.n.01_1']\n['ontop', 'sugar.n.01_1', 'countertop.n.01_1']\n['ontop', 'sugar.n.01_2', 'countertop.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"storing_food\",\n    \"Goal Instructions\": \"Store food into the cabinet.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "storing_the_groceries_0_Beechwood_0_int_0_2021-10-26_13-13-47",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ncereal.n.03_1: []\ncereal.n.03_2: []\ncountertop.n.01_1: ['Stained', 'Dusty']\nlettuce.n.03_1: ['Frozen']\nlettuce.n.03_2: ['Frozen']\nbroccoli.n.02_1: ['Frozen', 'Cooked', 'Burnt']\nbroccoli.n.02_2: ['Frozen', 'Cooked', 'Burnt']\nraspberry.n.02_1: ['Frozen', 'Cooked', 'Burnt']\nraspberry.n.02_2: ['Frozen', 'Cooked', 'Burnt']\npork.n.01_1: ['Frozen', 'Cooked', 'Burnt']\npork.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'cereal.n.03_1', 'countertop.n.01_1']\n['ontop', 'cereal.n.03_2', 'countertop.n.01_1']\n['ontop', 'lettuce.n.03_1', 'countertop.n.01_1']\n['ontop', 'lettuce.n.03_2', 'countertop.n.01_1']\n['ontop', 'broccoli.n.02_1', 'countertop.n.01_1']\n['ontop', 'broccoli.n.02_2', 'countertop.n.01_1']\n['ontop', 'raspberry.n.02_1', 'countertop.n.01_1']\n['ontop', 'raspberry.n.02_2', 'countertop.n.01_1']\n['ontop', 'pork.n.01_1', 'countertop.n.01_1']\n['ontop', 'pork.n.01_2', 'countertop.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"storing_the_groceries\",\n    \"Goal Instructions\": \"Store the groceries into the fridge and the cabinet based on your common sense. Place groceries of the same type next to each other.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "thawing_frozen_food_0_Pomaria_1_int_0_2021-10-26_13-10-33",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\ndate.n.08_1: ['Frozen', 'Cooked', 'Burnt']\nelectric_refrigerator.n.01_1: ['Stained', 'Open', 'Dusty']\nolive.n.04_1: ['Frozen', 'Cooked', 'Burnt']\nfish.n.02_1: ['Frozen', 'Cooked', 'Burnt']\nfish.n.02_2: ['Frozen', 'Cooked', 'Burnt']\nfish.n.02_3: ['Frozen', 'Cooked', 'Burnt']\nfish.n.02_4: ['Frozen', 'Cooked', 'Burnt']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['inside', 'date.n.08_1', 'electric_refrigerator.n.01_1']\n['inside', 'olive.n.04_1', 'electric_refrigerator.n.01_1']\n['inside', 'fish.n.02_1', 'electric_refrigerator.n.01_1']\n['inside', 'fish.n.02_2', 'electric_refrigerator.n.01_1']\n['inside', 'fish.n.02_3', 'electric_refrigerator.n.01_1']\n['inside', 'fish.n.02_4', 'electric_refrigerator.n.01_1']\n['frozen', 'fish.n.02_1']\n['frozen', 'fish.n.02_2']\n['frozen', 'fish.n.02_3']\n['frozen', 'fish.n.02_4']\n['frozen', 'date.n.08_1']\n['frozen', 'olive.n.04_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"thawing_frozen_food\",\n    \"Goal Instructions\": \"Place the frozen food items next to the sink to thaw.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "throwing_away_leftovers_0_Ihlen_1_int_0_2021-06-04_19-52-40",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nplate.n.04_1: ['Stained', 'Dusty']\nplate.n.04_2: ['Stained', 'Dusty']\nplate.n.04_3: ['Stained', 'Dusty']\nplate.n.04_4: ['Stained', 'Dusty']\nhamburger.n.01_1: ['Frozen', 'Cooked', 'Burnt']\nhamburger.n.01_2: ['Frozen', 'Cooked', 'Burnt']\nhamburger.n.01_3: ['Frozen', 'Cooked', 'Burnt']\ncountertop.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nashcan.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'plate.n.04_1', 'countertop.n.01_1']\n['ontop', 'hamburger.n.01_1', 'plate.n.04_1']\n['ontop', 'plate.n.04_2', 'countertop.n.01_1']\n['ontop', 'hamburger.n.01_3', 'plate.n.04_2']\n['ontop', 'plate.n.04_3', 'countertop.n.01_1']\n['ontop', 'hamburger.n.01_2', 'plate.n.04_3']\n['ontop', 'plate.n.04_4', 'countertop.n.01_1']\n['onfloor', 'ashcan.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"throwing_away_leftovers\",\n    \"Goal Instructions\": \"Throw away all leftover hamburgers into the trash.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "unpacking_suitcase_0_Benevolence_1_int_0_2021-06-08_17-58-34",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nsock.n.01_1: ['Stained', 'Dusty']\nsock.n.01_2: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ncarton.n.02_1: ['Open', 'Dusty']\nperfume.n.02_1: ['Frozen']\ntoothbrush.n.01_1: ['Stained', 'Dusty']\nnotebook.n.01_1: ['Dusty']\nsofa.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'carton.n.02_1', 'floor.n.01_1']\n['inside', 'sock.n.01_1', 'carton.n.02_1']\n['inside', 'sock.n.01_2', 'carton.n.02_1']\n['inside', 'perfume.n.02_1', 'carton.n.02_1']\n['inside', 'toothbrush.n.01_1', 'carton.n.02_1']\n['inside', 'notebook.n.01_1', 'carton.n.02_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"unpacking_suitcase\",\n    \"Goal Instructions\": \"Place the carton on the floor, then take everything from the carton and place them on the sofa.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "vacuuming_floors_0_Ihlen_1_int_0_2021-06-08_18-03-55",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nfloor.n.01_1: ['Stained', 'Dusty']\nvacuum.n.04_1: ['ToggledOn', 'Stained', 'Dusty']\nashcan.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['dusty', 'floor.n.01_1']\n['onfloor', 'vacuum.n.04_1', 'floor.n.01_1']\n['onfloor', 'ashcan.n.01_1', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"vacuuming_floors\",\n    \"Goal Instructions\": \"Vacuum the dusty floors.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "washing_cars_or_other_vehicles_0_Ihlen_0_int_0_2021-10-25_22-38-10",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nsoap.n.01_1: []\ncar.n.01_1: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nbucket.n.01_1: ['Stained', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'soap.n.01_1', 'car.n.01_1']\n['onfloor', 'car.n.01_1', 'floor.n.01_1']\n['ontop', 'bucket.n.01_1', 'car.n.01_1']\n['ontop', 'rag.n.01_1', 'car.n.01_1']\n['dusty', 'car.n.01_1']\n['stained', 'car.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"washing_cars_or_other_vehicles\",\n    \"Goal Instructions\": \"Wash all dust and stains from the car or vehicle.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "washing_dishes_0_Benevolence_1_int_0_2021-06-08_18-07-48",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nplate.n.04_1: ['Stained', 'Dusty']\nplate.n.04_2: ['Stained', 'Dusty']\ncup.n.01_1: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nbowl.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\nscrub_brush.n.01_1: ['Stained', 'Soaked', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'plate.n.04_1', 'countertop.n.01_1']\n['ontop', 'plate.n.04_2', 'countertop.n.01_1']\n['ontop', 'bowl.n.01_1', 'countertop.n.01_1']\n['ontop', 'cup.n.01_1', 'countertop.n.01_1']\n['inside', 'scrub_brush.n.01_1', 'sink.n.01_1']\n['stained', 'plate.n.04_1']\n['stained', 'plate.n.04_2']\n['stained', 'cup.n.01_1']\n['stained', 'bowl.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"washing_dishes\",\n    \"Goal Instructions\": \"Wash all the stained plates, cups, and bowls.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "washing_floor_0_Ihlen_1_int_1_2021-10-26_14-53-28",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nbucket.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nsoap.n.01_1: []\ntowel.n.01_1: ['Stained', 'Soaked', 'Dusty']\nshower.n.01_1: ['Stained']\ntoilet.n.02_1: ['Stained', 'Dusty']\nbed.n.01_1: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'bucket.n.01_1', 'floor.n.01_1']\n['ontop', 'soap.n.01_1', 'towel.n.01_1']\n['onfloor', 'soap.n.01_1', 'floor.n.01_1']\n['onfloor', 'towel.n.01_1', 'floor.n.01_1']\n['not', 'stained', 'towel.n.01_1']\n['dusty', 'floor.n.01_1']\n['stained', 'floor.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"washing_floor\",\n    \"Goal Instructions\": \"Clean the dust and stain off the floor.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "washing_pots_and_pans_0_Pomaria_1_int_0_2021-10-26_13-06-44",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nteapot.n.01_1: ['Stained', 'Dusty']\nkettle.n.01_1: ['Stained', 'Dusty']\npan.n.01_1: ['Stained', 'Dusty']\npan.n.01_2: ['Stained', 'Dusty']\npan.n.01_3: ['Stained', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\ncountertop.n.01_2: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\nscrub_brush.n.01_1: ['Stained', 'Soaked', 'Dusty']\nsoap.n.01_1: []\ncabinet.n.01_1: ['Stained', 'Open', 'Dusty']\ncabinet.n.01_2: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['ontop', 'teapot.n.01_1', 'countertop.n.01_1']\n['stained', 'teapot.n.01_1']\n['ontop', 'kettle.n.01_1', 'countertop.n.01_2']\n['stained', 'kettle.n.01_1']\n['ontop', 'pan.n.01_1', 'countertop.n.01_1']\n['stained', 'pan.n.01_1']\n['ontop', 'pan.n.01_2', 'countertop.n.01_1']\n['stained', 'pan.n.01_2']\n['ontop', 'pan.n.01_3', 'countertop.n.01_2']\n['stained', 'pan.n.01_3']\n['ontop', 'scrub_brush.n.01_1', 'countertop.n.01_2']\n['soaked', 'scrub_brush.n.01_1']\n['inside', 'soap.n.01_1', 'sink.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"washing_pots_and_pans\",\n    \"Goal Instructions\": \"Clean all the stained pans, kettles, and teapots and place them inside a cabinet.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "watering_houseplants_0_Beechwood_0_int_0_2021-10-26_15-20-01",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\npot_plant.n.01_1: ['Soaked']\npot_plant.n.01_2: ['Soaked']\npot_plant.n.01_3: ['Soaked']\nfloor.n.01_1: ['Stained', 'Dusty']\nfloor.n.01_2: ['Stained', 'Dusty']\nsink.n.01_1: ['ToggledOn', 'Stained', 'Dusty']\ntable.n.02_1: ['Stained', 'Dusty']\ncountertop.n.01_1: ['Stained', 'Dusty']\n\nAll initial states in the scene are:\n['onfloor', 'pot_plant.n.01_1', 'floor.n.01_1']\n['onfloor', 'pot_plant.n.01_2', 'floor.n.01_1']\n['onfloor', 'pot_plant.n.01_3', 'floor.n.01_2']\n['not', 'soaked', 'pot_plant.n.01_1']\n['not', 'soaked', 'pot_plant.n.01_2']\n['not', 'soaked', 'pot_plant.n.01_3']\n['onfloor', 'agent.n.01_1', 'floor.n.01_2']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"watering_houseplants\",\n    \"Goal Instructions\": \"Water each houseplant thoroughly.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    },
    {
        "identifier": "waxing_cars_or_other_vehicles_0_Ihlen_0_int_0_2021-10-25_23-03-46",
        "llm_prompt": "You are a helpful assistant for goal interpretation in an embodied environment. You should only output in json format. Your task is to understand natural language goals for a household robot, reason about the object states and relationships, and turn natural language goals into symbolic goal states in the designated format. The goals include: unary goals describing one object's own unary states, and binary goals describing object-object binary relationships. The input will be the goal's name, the goal's description, relevant objects as well as their possible unary states, and all initial unary and binary states. The output should be the symbolic version of the goal states.\n\n\nRelevant objects in the scene indicates those objects involved in the action execution initially. It will include the object name, and the object's all possible unary states (In goal conditions, each state can be set to true: [\"Stained\", \"cup.n.01_1\"] or not true: [\"not\", [\"Stained\", \"cup.n.01_1\"]]). It follows the format: object name including object id, possible unary states: ...(all possible unary states). Your proposed unary object states should be within the following set: {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}\n\n\nRelevant objects in the scene are:\nvehicle.n.01_1: ['Stained', 'Open', 'Dusty']\nfloor.n.01_1: ['Stained', 'Dusty']\nvessel.n.03_1: ['Stained', 'Dusty']\nshelf.n.01_1: ['Stained', 'Dusty']\nrag.n.01_1: ['Stained', 'Soaked']\n\nAll initial states in the scene are:\n['onfloor', 'vehicle.n.01_1', 'floor.n.01_1']\n['dusty', 'vehicle.n.01_1']\n['ontop', 'vessel.n.03_1', 'shelf.n.01_1']\n['inside', 'rag.n.01_1', 'shelf.n.01_1']\n['onfloor', 'agent.n.01_1', 'floor.n.01_1']\n\nSymbolic goals format:\n\nNode goal states should be a set indicating the desired final goal states of single objects. Each goal in the list should be a list with two elements: the first element is the state name, which comes from the set {\"Cooked\", \"Open\", \"Frozen\", \"Dusty\", \"Stained\", \"Sliced\", \"Soaked\", \"Toggled_On\"}; the second element is the object name, which comes from the list of relevant objects in the scene provided above An example being [\"Frozen\", \"chicken.n.01_1\"]. To indicate the negation of a state such as the above example, simply use the format [\"not\", [\"Frozen\", \"chicken.n.01_1\"]].\n\n\nEdge goal states should be a set indicating the desired binary relationships between two objects. Each goal state in the set is a list of three elements: the first element is the state name, which comes from the set {\"NextTo\", \"Inside\", \"OnFloor\", \"Touching\", \"Under\"}, the second and third elements are the object names, with relationship as indicated by the first element. For example, the edge goal condition [\"inside\", \"tomato.n.01_2\", \"electric_refrigerator.n.01_1\"] indicates that the object \"tomato.n.01_2\" is inside \"electric_refrigerator.n.01_1\", and the edge goal condition [\"ontop\", \"plate.n.04_1\", \"countertop.n.01_1\"] indicates that the object \"plate.n.04_1\" is ontop of the object \"countertop.n.01_1\". Similar to node goal states, edge goal states and also be negated by simply nesting inside a \"not\", for example [\"not\", [\"inside\", \"peach.n.03_1\", \"jar.n.01_2\"]] means that the object \"peach.n.03_1\" is not inside the object \"jar.n.01_2\".\n\n\nTask Name and Goal Instructions:\n{\n    \"Task Name\": \"waxing_cars_or_other_vehicles\",\n    \"Goal Instructions\": \"Wax the dust off the vehicle.\"\n}\n\nNow using json format, output just the symbolic version of the goal states without any explanation. Output a single json object string, whose keys are 'node goals' and 'edge goals', and values are your output of symbolic node goals and symbolic edge goals, respectively. That is, your output should be of the format: {\"node goals\": SYMBOLIC_NODE_GOALS, \"edge goals\": SYMBOLIC_EDGE_GOALS}. Also, please strictly follow the aforementioned symbolic goal format."
    }
]